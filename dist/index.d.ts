// Generated by dts-bundle-generator v8.0.1

import { Camera } from '@babylonjs/core/Cameras/camera';
import { BoundingBox } from '@babylonjs/core/Culling/boundingBox';
import { Constants } from '@babylonjs/core/Engines/constants';
import { Engine } from '@babylonjs/core/Engines/engine';
import { ICanvasRenderingContext } from '@babylonjs/core/Engines/ICanvas';
import { GlowLayer, IGlowLayerOptions } from '@babylonjs/core/Layers/glowLayer';
import { PBRMaterial } from '@babylonjs/core/Materials/PBR/pbrMaterial';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Texture } from '@babylonjs/core/Materials/Textures/texture';
import { Color3, Color4 } from '@babylonjs/core/Maths/math.color';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { AbstractMesh } from '@babylonjs/core/Meshes/abstractMesh';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { IParticleSystem } from '@babylonjs/core/Particles/IParticleSystem';
import { SolidParticleSystem } from '@babylonjs/core/Particles/solidParticleSystem';
import { Scene } from '@babylonjs/core/scene';
import { Sprite } from '@babylonjs/core/Sprites/sprite';
import { SpriteManager } from '@babylonjs/core/Sprites/spriteManager';
import { Nullable } from '@babylonjs/core/types';
import { TSchema } from '@sinclair/typebox';
import QixColor from 'color';
import { Properties } from 'csstype';
import stableStringify from 'json-stable-stringify';
import { Body, Engine, IBodyRenderOptions, World } from 'matter-js';
import React from 'react';
import { CSSProperties, KeyboardEventHandler, MouseEventHandler, ReactChild, ReactNode } from 'react';
import ReactDOM from 'react-dom/client';
import { useDropzone } from 'react-dropzone';
import { StoreApi, UseBoundStore } from 'zustand';

export interface ModelInfo {
	model_name: string;
	lora_names: any[];
	"shared.settings": SharedSettings;
	"shared.args": SharedArgs;
}
export interface SharedSettings {
	dark_theme: boolean;
	autoload_model: boolean;
	max_new_tokens: number;
	max_new_tokens_min: number;
	max_new_tokens_max: number;
	seed: number;
	character: string;
	name1: string;
	name2: string;
	context: string;
	greeting: string;
	turn_template: string;
	custom_stopping_strings: string;
	stop_at_newline: boolean;
	add_bos_token: boolean;
	ban_eos_token: boolean;
	skip_special_tokens: boolean;
	truncation_length: number;
	truncation_length_min: number;
	truncation_length_max: number;
	mode: string;
	start_with: string;
	chat_style: string;
	instruction_template: string;
	"chat-instruct_command": string;
	chat_generation_attempts: number;
	chat_generation_attempts_min: number;
	chat_generation_attempts_max: number;
	default_extensions: any[];
	chat_default_extensions: string[];
	preset: string;
	prompt: string;
}
export interface SharedArgs {
	notebook: boolean;
	chat: boolean;
	character: any;
	model: any;
	lora: any;
	model_dir: string;
	lora_dir: string;
	model_menu: boolean;
	no_stream: boolean;
	settings: any;
	extensions: string[];
	verbose: boolean;
	loader: string;
	cpu: boolean;
	auto_devices: boolean;
	gpu_memory: string[];
	cpu_memory: any;
	disk: boolean;
	disk_cache_dir: string;
	load_in_8bit: boolean;
	bf16: boolean;
	no_cache: boolean;
	xformers: boolean;
	sdp_attention: boolean;
	trust_remote_code: boolean;
	load_in_4bit: boolean;
	compute_dtype: string;
	quant_type: string;
	use_double_quant: boolean;
	threads: number;
	n_batch: number;
	no_mmap: boolean;
	mlock: boolean;
	cache_capacity: any;
	n_gpu_layers: number;
	n_ctx: number;
	llama_cpp_seed: number;
	wbits: number;
	model_type: string;
	groupsize: number;
	pre_layer: any;
	checkpoint: any;
	monkey_patch: boolean;
	quant_attn: boolean;
	warmup_autotune: boolean;
	fused_mlp: boolean;
	gptq_for_llama: boolean;
	autogptq: boolean;
	triton: boolean;
	no_inject_fused_attention: boolean;
	no_inject_fused_mlp: boolean;
	no_use_cuda_fp16: boolean;
	desc_act: boolean;
	gpu_split: string;
	max_seq_len: number;
	compress_pos_emb: number;
	flexgen: boolean;
	percent: number[];
	compress_weight: boolean;
	pin_weight: boolean;
	deepspeed: boolean;
	nvme_offload_dir: any;
	local_rank: number;
	rwkv_strategy: any;
	rwkv_cuda_on: boolean;
	listen: boolean;
	listen_host: any;
	listen_port: any;
	share: boolean;
	auto_launch: boolean;
	gradio_auth: any;
	gradio_auth_path: any;
	api: boolean;
	api_blocking_port: number;
	api_streaming_port: number;
	public_api: boolean;
	multimodal_pipeline: any;
}
export declare const TextGens: {
	textgen: (prompt: string, paramOverrides?: Partial<TextGenParams>) => Promise<string>;
	useTextGenState: import("zustand").UseBoundStore<import("zustand").StoreApi<{
		debug: boolean;
		promptTemplate: string;
		baseUrl: string;
		textgenParams: Partial<TextGenParams>;
		monitor: MonitorFunction;
	}>>;
	textToTokens: (text: string) => string[];
	modelInfo: () => Promise<ModelInfo> | undefined;
	loadModel: (modelName: string, options?: Partial<{
		loader: "AutoGPTQ" | "ExLlama" | "ExLlama_HF";
		auto_devices: boolean;
		max_seq_len: number;
		compress_pos_emb: number;
	}>) => Promise<ModelInfo> | undefined;
	extractMarkdownText: (markdown: string, type?: string) => string;
};
/** ImageToImageResponse */
export interface ImageToImageResponse {
	/**
	 * Image
	 * The generated image in base64 format.
	 */
	images?: string[];
	/** Parameters */
	parameters: object;
	/** Info */
	info: string;
}
/** StableDiffusionProcessingTxt2Img */
export interface StableDiffusionProcessingTxt2Img {
	/**
	 * Enable Hr
	 * @default false
	 */
	enable_hr?: boolean;
	/**
	 * Denoising Strength
	 * @default 0
	 */
	denoising_strength?: number;
	/**
	 * Firstphase Width
	 * @default 0
	 */
	firstphase_width?: number;
	/**
	 * Firstphase Height
	 * @default 0
	 */
	firstphase_height?: number;
	/**
	 * Hr Scale
	 * @default 2
	 */
	hr_scale?: number;
	/** Hr Upscaler */
	hr_upscaler?: string;
	/**
	 * Hr Second Pass Steps
	 * @default 0
	 */
	hr_second_pass_steps?: number;
	/**
	 * Hr Resize X
	 * @default 0
	 */
	hr_resize_x?: number;
	/**
	 * Hr Resize Y
	 * @default 0
	 */
	hr_resize_y?: number;
	/** Hr Sampler Name */
	hr_sampler_name?: string;
	/**
	 * Hr Prompt
	 * @default ""
	 */
	hr_prompt?: string;
	/**
	 * Hr Negative Prompt
	 * @default ""
	 */
	hr_negative_prompt?: string;
	/**
	 * Prompt
	 * @default ""
	 */
	prompt?: string;
	/** Styles */
	styles?: string[];
	/**
	 * Seed
	 * @default -1
	 */
	seed?: number;
	/**
	 * Subseed
	 * @default -1
	 */
	subseed?: number;
	/**
	 * Subseed Strength
	 * @default 0
	 */
	subseed_strength?: number;
	/**
	 * Seed Resize From H
	 * @default -1
	 */
	seed_resize_from_h?: number;
	/**
	 * Seed Resize From W
	 * @default -1
	 */
	seed_resize_from_w?: number;
	/** Sampler Name */
	sampler_name?: string;
	/**
	 * Batch Size
	 * @default 1
	 */
	batch_size?: number;
	/**
	 * N Iter
	 * @default 1
	 */
	n_iter?: number;
	/**
	 * Steps
	 * @default 50
	 */
	steps?: number;
	/**
	 * Cfg Scale
	 * @default 7
	 */
	cfg_scale?: number;
	/**
	 * Width
	 * @default 512
	 */
	width?: number;
	/**
	 * Height
	 * @default 512
	 */
	height?: number;
	/**
	 * Restore Faces
	 * @default false
	 */
	restore_faces?: boolean;
	/**
	 * Tiling
	 * @default false
	 */
	tiling?: boolean;
	/**
	 * Do Not Save Samples
	 * @default false
	 */
	do_not_save_samples?: boolean;
	/**
	 * Do Not Save Grid
	 * @default false
	 */
	do_not_save_grid?: boolean;
	/** Negative Prompt */
	negative_prompt?: string;
	/** Eta */
	eta?: number;
	/**
	 * S Min Uncond
	 * @default 0
	 */
	s_min_uncond?: number;
	/**
	 * S Churn
	 * @default 0
	 */
	s_churn?: number;
	/** S Tmax */
	s_tmax?: number;
	/**
	 * S Tmin
	 * @default 0
	 */
	s_tmin?: number;
	/**
	 * S Noise
	 * @default 1
	 */
	s_noise?: number;
	/** Override Settings */
	override_settings?: object;
	/**
	 * Override Settings Restore Afterwards
	 * @default true
	 */
	override_settings_restore_afterwards?: boolean;
	/**
	 * Script Args
	 * @default []
	 */
	script_args?: any[];
	/**
	 * Sampler Index
	 * @default "Euler"
	 */
	sampler_index?: string;
	/** Script Name */
	script_name?: string;
	/**
	 * Send Images
	 * @default true
	 */
	send_images?: boolean;
	/**
	 * Save Images
	 * @default false
	 */
	save_images?: boolean;
	/**
	 * Alwayson Scripts
	 * @default {}
	 */
	alwayson_scripts?: object;
}
/** TextToImageResponse */
export interface TextToImageResponse {
	/**
	 * Image
	 * The generated image in base64 format.
	 */
	images?: string[];
	/** Parameters */
	parameters: object;
	/** Info */
	info: string;
}
export declare const ImageGens: {
	txt2img: (options: StableDiffusionProcessingTxt2Img & Partial<{
		signal: AbortSignal;
	}>) => Promise<TextToImageResponse | undefined>;
	img2img: (src: HTMLCanvasElement, mask: HTMLCanvasElement, options: StableDiffusionProcessingTxt2Img & Partial<{
		signal: AbortSignal;
		outpainting_fill: 0 | 1 | 2 | 3;
		inpainting_fill: 0 | 1 | 2 | 3;
	}>) => Promise<ImageToImageResponse | undefined>;
	useImageGenState: import("zustand").UseBoundStore<import("zustand").StoreApi<{
		automaticBaseUrl: string;
		debug: boolean;
		monitor: MonitorFunction;
	}>>;
	drawTxt2Img: (canvasOrContext: HTMLCanvasElement | CanvasRenderingContext2D, txt2imgOptions?: StableDiffusionProcessingTxt2Img, canvasOptions?: Partial<{
		x: number;
		y: number;
		width: number;
		height: number;
	}>) => Promise<void>;
};
export type MonitorFunction = (message: string, state: "CALL" | "RESPONSE" | "ERROR", traceId: number | string) => void;
export type TextGenParams = {
	signal: AbortSignal;
	prompt: string;
	max_new_tokens: number;
	add_bos_token: boolean;
	skip_special_tokens: boolean;
	seed: number;
	stopping_strings: string[];
	repetition_penalty: number;
	top_p: number;
	min_length: number;
	preset: "None" | string;
	temperature: number;
};
export type OpenAiMessage = {
	name?: string;
	role: "user" | "assistant" | "system";
	content: string;
};
export interface OpenAiChatChoice {
	message: OpenAiMessage;
	index: number;
	logprobs: any;
	finish_reason: string;
}
export type OpenAiCommonRequest = {
	model: string;
	seed: number;
	max_tokens: number;
	temperature: number;
	top_p: number;
	top_k?: number;
	frequency_penalty?: number;
	presence_penalty?: number;
	repetition_penalty?: number;
	stream: boolean;
	response_format?: {
		type: "text" | "json_object";
	};
	logit_bias?: {
		[key: number]: number;
	};
	transforms?: string[];
	models?: string[];
	route?: "fallback";
};
export type OpenAiChatCompletionsRequest = OpenAiCommonRequest & {
	messages: OpenAiMessage[];
	mode: "instruct" | "chat" | "chat-instruct";
};
export type OpenAiCompletionsRequest = OpenAiCommonRequest & {
	prompt: string;
};
export type OpenAiUrlImage = {
	url: string;
};
export type OpenAib64JsonImage = {
	b64_json: string;
};
export type OpenAiImage = OpenAiUrlImage | OpenAib64JsonImage;
export type OpenAiImagesRequest = {
	prompt: string;
	model?: string;
	n?: number;
	quality?: string;
	response_format?: "url" | "b64_json";
	size?: string;
	style?: "vivid" | "natural";
	user?: string;
};
export type OpenAiImagesResponse = {
	created: number;
	data: OpenAiImage[];
};
export interface OpenAiUsage {
	prompt_tokens: number;
	completion_tokens: number;
	total_tokens: number;
}
export interface OpenAiMessageResponse {
	id: string;
	object: string;
	created: number;
	model: string;
	choices: OpenAiChatChoice[];
	usage?: OpenAiUsage;
}
export interface OpenAiTextChoice {
	text: string;
	index: number;
	logprobs: any;
	finish_reason: string;
}
export interface OpenAiTextResponse {
	id: string;
	object: string;
	created: number;
	model: string;
	choices: OpenAiTextChoice[];
	usage?: OpenAiUsage;
}
export declare const isOpenAiTextResponse: (maybe: unknown) => maybe is OpenAiTextResponse;
export interface OpenAiChatCompletionsChunkResponse {
	id: string;
	object: string;
	created: number;
	model: string;
	system_fingerprint: string;
	choices: Choice[];
}
export interface Choice {
	index: number;
	delta: Delta;
	finish_reason: any;
}
export interface Delta {
	role: string;
	content: string;
}
export type CloudflareAiResponse = {
	response: string;
};
export declare const CLOUDFLARE_AI_DONE_CHUNK = "[DONE]";
export type CloudflareAiChunkResponse = CloudflareAiResponse | typeof CLOUDFLARE_AI_DONE_CHUNK;
export type CloudflareAiTextGenerationRequest = {
	prompt?: string;
	stream?: boolean;
	max_tokens?: number;
	messages?: RoleScopedChatInput[];
};
export type RoleScopedChatInput = {
	role: string;
	content: string;
};
export declare const isCloudflareAiResponse: (maybe: unknown) => maybe is CloudflareAiResponse;
export declare const Animates: {
	create: ({ ticksPerSecond, ticker: tickable, running, signal, errorHandler, request, }: AnimationLoopConfig) => AnimateState;
};
export type Tick = {
	lastTickMs: number;
	nextTickMs: number;
	tickCount: number;
	tickStepMs: number;
	frameCount: number;
	deltaMs: number;
	lastDeltaMs: number;
	costMs: number;
	rateLimit: boolean;
};
export type Ticker<R = unknown> = (tick: Tick) => Promise<R> | R;
export type AnimateState = Tick & {
	tickers: Ticker[];
	running: boolean;
	abort: boolean;
	abortController: AbortController;
	destroy: () => void;
};
export type AnimationRequestFunction = (callback: (time: number) => void) => number;
export type AnimationLoopConfig = {
	ticksPerSecond?: number;
	ticker?: Ticker | Ticker[];
	running?: boolean;
	signal?: AbortSignal;
	errorHandler?: (error: unknown) => void;
	request?: AnimationRequestFunction;
};
export type AssertionMessage = string | (() => unknown);
declare function assert(value: boolean, message?: AssertionMessage): void;
declare function assertType<T>(value: unknown, typeGuard: (maybe: unknown) => maybe is T, message?: AssertionMessage): T;
declare function assertUnreachable(value: never, message?: AssertionMessage): never;
declare function assertValue<T>(maybe: T, message?: AssertionMessage): NonNullable<T>;
export type ListLike = ArrayLike<unknown> | ArrayBufferLike | ArrayBufferView | {
	length: number;
	[index: number]: unknown;
};
export declare const Asserts: {
	assert: typeof assert;
	assertUnreachable: typeof assertUnreachable;
	assertValue: typeof assertValue;
	assertEqual: <T>(a: T, b: T, message?: AssertionMessage) => void;
	assertNotEqual: <T_1>(a: T_1, b: T_1, message?: AssertionMessage) => void;
	assertEqualElements: (a: ListLike, b: ListLike, message?: AssertionMessage) => never;
	assertType: typeof assertType;
};
export declare const assert: typeof assert, assertValue: typeof assertValue, assertUnreachable: typeof assertUnreachable, assertType: typeof assertType;
export type WH = [
	number,
	number
];
export type WHD = [
	number,
	number,
	number
];
export type Ratio = number;
export type PointObject = PointObject1 | PointObject2 | PointObject3 | PointObject4;
export type PointObject1 = {
	x: number;
};
export type PointObject2 = PointObject1 & {
	y: number;
};
export type PointObject3 = PointObject2 & {
	z: number;
};
export type PointObject4 = PointObject3 & {
	w: number;
};
export type Vec = Vec0 | Vec1 | Vec2 | Vec3 | Vec4;
export type Vec0 = readonly number[];
export type Vec1 = readonly [
	number
];
export type Vec2 = readonly [
	number,
	number
];
export type Vec3 = readonly [
	number,
	number,
	number
];
export type Vec4 = readonly [
	number,
	number,
	number,
	number
];
export type Point = Point0 | (PointObject | Vec);
export type Point0 = Point1 | number;
export type Point1 = Point2 | (PointObject1 | Vec1);
export type Point2 = Point3 | (PointObject2 | Vec2);
export type Point3 = Point4 | (PointObject3 | Vec3);
export type Point4 = PointObject4 | Vec4;
export type XY = Vec2;
export type XYA = Vec3;
export type XYZ = Vec3;
export type XYZW = Vec4;
export type XYZA = Vec4;
export type Transform3 = {
	position: Point3;
	rotation: Point3;
	scale: Point3;
};
export declare const add: (a: number, b: number) => number;
export declare function add0(a: Point0, b: Point0): Point0;
export declare function add1(a: Point1, b: Point1): Point1;
export declare function add2(a: Point2, b: Point2): Point2;
export declare function add3(a: Point3, b: Point3): Point3;
export declare function add4(a: Point4, b: Point4): Point4;
export declare function addPoint(a: Point, b: Point): Point0;
export declare const aOf: <T>(pointVector: T[]) => T;
/**
 * blend two points via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha 0..1
 */
export declare function blend(a: number, b: number, alpha: number): number;
/**
 * blend two points via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha 0..1
 */
export declare function blend0(a: Point0, b: Point0, alpha: Point0): Point0;
/**
 * blend two point1s via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha
 */
export declare function blend1(a: Point1, b: Point1, alpha: Point1): Point1;
/**
 * blend two point2s via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha
 */
export declare function blend2(a: Point2, b: Point2, alpha: Point2): Point2;
/**
 * blend two point3s via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha
 */
export declare function blend3(a: Point3, b: Point3, alpha: Point3): Point3;
/**
 * blend two point3s via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha
 */
export declare function blend4(a: Point4, b: Point4, alpha: Point4): Point4;
export declare function blendPoint(a: Point, b: Point, alpha: Point): Point;
export declare const bOf: <T>(pointVector: T[]) => T;
export declare function clamp(num: number, min: number, max: number): number;
export declare const cOf: <T>(pointVector: T[]) => T;
export declare const contains: (point: Point, needle: number) => boolean;
export declare function distance(a: number, b: number): number;
export declare function distance0(a: Point0, b: Point0): number;
export declare function distance1(a: Point1, b: Point1): number;
export declare function distance2(a: Point2, b: Point2): number;
export declare function distance3(a: Point3, b: Point3): number;
export declare function distance4(a: Point4, b: Point4): number;
export declare function distancePoint(a: Point, b: Point): number;
export declare function distancePoints2(points: Point2[]): number;
export declare function divide(a: number, b: number): number;
export declare function divide0(a: Point0, b: Point0): Point0;
export declare function divide1(a: Point1, b: Point1): Point1;
export declare function divide2(a: Point2, b: Point2): Point2;
export declare function divide3(a: Point3, b: Point3): Point3;
export declare function divide4(a: Point4, b: Point4): Point4;
export declare const dividePoint: (a: Point, b: Point) => Point;
export declare const dOf: <T>(pointVector: T[]) => T;
export declare const eOf: <T>(pointVector: T[]) => T;
export declare function isPoint(maybe: unknown): maybe is Point;
export declare function isPoint0(maybe: unknown): maybe is Point0;
export declare function isPoint1(maybe: unknown): maybe is Point1;
export declare function isPoint2(maybe: unknown): maybe is Point2;
export declare function isPoint3(maybe: unknown): maybe is Point3;
export declare function isPoint4(maybe: unknown): maybe is Point4;
export declare function isPointObject1(maybe: unknown): maybe is PointObject1;
export declare function isPointObject2(maybe: unknown): maybe is PointObject2;
export declare function isPointObject3(maybe: unknown): maybe is PointObject3;
export declare function isPointObject4(maybe: unknown): maybe is PointObject4;
export declare function isVec(maybe: unknown): maybe is Vec;
export declare function isVec0(maybe: unknown): maybe is Vec0;
export declare function isVec1(maybe: unknown): maybe is Vec1;
export declare function isVec2(maybe: unknown): maybe is Vec2;
export declare function isVec3(maybe: unknown): maybe is Vec3;
export declare function isVec4(maybe: unknown): maybe is Vec4;
export declare function jsonToPoint3(json: string): Point3;
export declare function length0(p: Point0): number;
export declare function length1(p: Point1): number;
export declare function length2(p: Point2): number;
export declare function length3(p: Point3): number;
export declare function length4(p: Point4): number;
export declare function lengthPoint(p: Point): number;
export declare function lerp(v0: number, v1: number, amount: number): number;
export declare const lerp0: (a: Point0, b: Point0, alpha: number) => Point0;
export declare const lerp1: (a: Point1, b: Point1, alpha: number) => Point1;
export declare const lerp2: (a: Point2, b: Point2, alpha: number) => Point2;
export declare const lerp3: (a: Point3, b: Point3, alpha: number) => Point3;
export declare const lerp4: (a: Point4, b: Point4, alpha: number) => Point4;
export declare const lerpPoint: (a: Point, b: Point, alpha: number) => number | PointObject1 | Vec1 | Vec2 | Vec3 | Vec4;
export declare function midPoint3(a: Point3, b: Point3): Point3;
export declare function multiply(a: number, b: number): number;
export declare function multiply0(a: Point0, b: Point0): Point0;
export declare function multiply1(a: Point1, b: Point1): Point1;
export declare function multiply2(a: Point2, b: Point2): Point2;
export declare function multiply3(a: Point3, b: Point3): Point3;
export declare function multiply4(a: Point4, b: Point4): Point4;
export declare function multiplyPoint(a: Point, b: Point): Point;
export declare function normalize0(p: Point0): Point0;
export declare function normalize1(p: Point1): Point1;
export declare function normalize2(p: Point2): Point2;
export declare function normalize3(p: Point3): Point3;
export declare function normalize4(p: Point4): Point4;
export declare const normalizePoint: (point: Point) => Point;
export declare function point3ToJson(point3: Point3): string;
export declare const quant: ({ v, q, s, }: {
	v: number;
	q: number;
	s?: number;
}) => number;
export declare const scaler: (scale: number) => (value: number) => number;
export declare const scaler0: (scale: Point0) => (value: Point0) => Point0;
export declare const scaler1: (scale: Point1) => (value: Point1) => Point1;
export declare const scaler2: (scale: Point2) => (value: Point2) => Point2;
export declare const scaler3: (scale: Point3) => (value: Point3) => Point3;
export declare const scaler4: (scale: Point4) => (value: Point4) => Point4;
export declare const scalerPoint: (scale: Point) => ((value: Point0) => Point0) | ((value: Point1) => Point1) | ((value: Point2) => Point2) | ((value: Point3) => Point3) | ((value: Point4) => Point4);
export declare function subtract(a: number, b: number): number;
export declare function subtract0(a: Point0, b: Point0): Point0;
export declare function subtract1(a: Point1, b: Point1): Point1;
export declare function subtract2(a: Point2, b: Point2): Point2;
export declare function subtract3(a: Point3, b: Point3): Point3;
export declare function subtract4(a: Point4, b: Point4): Point4;
export declare function subtractPoint(a: Point, b: Point): Point;
export declare function toVec(point: Point): Vec;
/**
 * Promotes number to array
 */
export declare function toVec0(point: Point0): Vec0;
export declare function toVec1(point: Point1): Vec1;
export declare function toVec2(point: Point2): Vec2;
export declare function toVec3(point: Point3): Vec3;
export declare function toVec4(source: Point): Vec4;
export declare const translater: (a: number) => (b: number) => number;
export declare const translater0: (translatePoint: Point0) => (pos: Point0) => Point0;
export declare const translater1: (translatePoint: Point1) => (pos: Point1) => Point1;
export declare const translater2: (translatePoint: Point2) => (pos: Point2) => Point2;
export declare const translater3: (translatePoint: Point3) => (pos: Point3) => Point3;
export declare const translater4: (translatePoint: Point4) => (pos: Point4) => Point4;
export declare const translaterPoint: (translatePoint: Point) => (position: Point) => Point;
export declare function wOf(point: Point): number;
export declare function xOf(point: Point): number;
export declare function yOf(point: Point): number;
export declare function zOf(point: Point): number;
declare function length(p: number): number;
declare function midPoint2(a: Point2, b: Point2): Point2;
export declare const Maths: {
	toTransform3: (o3: Partial<Transform3>) => Transform3;
	add: (a: number, b: number) => number;
	add0: typeof add0;
	add1: typeof add1;
	add2: typeof add2;
	add3: typeof add3;
	add4: typeof add4;
	addPoint: typeof addPoint;
	blend: typeof blend;
	blend0: typeof blend0;
	blend1: typeof blend1;
	blend2: typeof blend2;
	blend3: typeof blend3;
	blend4: typeof blend4;
	blendPoint: typeof blendPoint;
	clamp: typeof clamp;
	contains: (point: Point, needle: number) => boolean;
	distance: typeof distance;
	distance0: typeof distance0;
	distance1: typeof distance1;
	distance2: typeof distance2;
	distance3: typeof distance3;
	distance4: typeof distance4;
	distancePoint: typeof distancePoint;
	divide: typeof divide;
	divide0: typeof divide0;
	divide1: typeof divide1;
	divide2: typeof divide2;
	divide3: typeof divide3;
	divide4: typeof divide4;
	dividePoint: (a: Point, b: Point) => Point;
	isPoint: typeof isPoint;
	isPoint0: typeof isPoint0;
	isPoint1: typeof isPoint1;
	isPoint2: typeof isPoint2;
	isPoint3: typeof isPoint3;
	isPoint4: typeof isPoint4;
	isPointObject1: typeof isPointObject1;
	isPointObject2: typeof isPointObject2;
	isPointObject3: typeof isPointObject3;
	isPointObject4: typeof isPointObject4;
	isVec: typeof isVec;
	isVec0: typeof isVec0;
	isVec1: typeof isVec1;
	isVec2: typeof isVec2;
	isVec3: typeof isVec3;
	isVec4: typeof isVec4;
	jsonToPoint3: typeof jsonToPoint3;
	length: typeof length;
	length0: typeof length0;
	length1: typeof length1;
	length2: typeof length2;
	length3: typeof length3;
	length4: typeof length4;
	lengthPoint: typeof lengthPoint;
	lerp: typeof lerp;
	lerp0: (a: Point0, b: Point0, alpha: number) => Point0;
	lerp1: (a: Point1, b: Point1, alpha: number) => Point1;
	lerp2: (a: Point2, b: Point2, alpha: number) => Point2;
	lerp3: (a: Point3, b: Point3, alpha: number) => Point3;
	lerp4: (a: Point4, b: Point4, alpha: number) => Point4;
	lerpPoint: (a: Point, b: Point, alpha: number) => number | PointObject1 | Vec4 | Vec3 | Vec2 | Vec1;
	midPoint2: typeof midPoint2;
	midPoint3: typeof midPoint3;
	multiply: typeof multiply;
	multiply0: typeof multiply0;
	multiply1: typeof multiply1;
	multiply2: typeof multiply2;
	multiply3: typeof multiply3;
	multiply4: typeof multiply4;
	multiplyPoint: typeof multiplyPoint;
	normalize0: typeof normalize0;
	normalize1: typeof normalize1;
	normalize2: typeof normalize2;
	normalize3: typeof normalize3;
	normalize4: typeof normalize4;
	normalizePoint: (point: Point) => Point;
	point3ToJson: typeof point3ToJson;
	scaler: (scale: number) => (value: number) => number;
	scaler0: (scale: Point0) => (value: Point0) => Point0;
	scaler1: (scale: Point1) => (value: Point1) => Point1;
	scaler2: (scale: Point2) => (value: Point2) => Point2;
	scaler3: (scale: Point3) => (value: Point3) => Point3;
	scaler4: (scale: Point4) => (value: Point4) => Point4;
	scalerPoint: (scale: Point) => ((value: Point0) => Point0) | ((value: Point1) => Point1) | ((value: Point2) => Point2) | ((value: Point3) => Point3) | ((value: Point4) => Point4);
	subtract: typeof subtract;
	subtract0: typeof subtract0;
	subtract1: typeof subtract1;
	subtract2: typeof subtract2;
	subtract3: typeof subtract3;
	subtract4: typeof subtract4;
	subtractPoint: typeof subtractPoint;
	toVec: typeof toVec;
	toVec0: typeof toVec0;
	toVec1: typeof toVec1;
	toVec2: typeof toVec2;
	toVec3: typeof toVec3;
	toVec4: typeof toVec4;
	translater: (a: number) => (b: number) => number;
	translater0: (translatePoint: Point0) => (pos: Point0) => Point0;
	translater1: (translatePoint: Point1) => (pos: Point1) => Point1;
	translater2: (translatePoint: Point2) => (pos: Point2) => Point2;
	translater3: (translatePoint: Point3) => (pos: Point3) => Point3;
	translater4: (translatePoint: Point4) => (pos: Point4) => Point4;
	translaterPoint: (translatePoint: Point) => (position: Point) => Point;
	wOf: typeof wOf;
	xOf: typeof xOf;
	yOf: typeof yOf;
	zOf: typeof zOf;
	aOf: <T>(pointVector: T[]) => T;
	bOf: <T_1>(pointVector: T_1[]) => T_1;
	cOf: <T_2>(pointVector: T_2[]) => T_2;
	dOf: <T_3>(pointVector: T_3[]) => T_3;
	eOf: <T_4>(pointVector: T_4[]) => T_4;
	distancePoints2: typeof distancePoints2;
	includesPoint: (points: Point[], p: Point) => boolean;
	removeDuplicatePoints: <P extends Point>(points: P[]) => P[];
	isEqual: (a: Point, b: Point) => boolean;
};
declare function v3(xOrPosition?: number | Point3 | Point2, y?: number, z?: number): Vector3;
export declare const Babs: {
	createEngine: (options?: import("@babylonjs/core").EngineOptions & {
		antialias?: boolean;
		width?: number;
		height?: number;
		canvas?: HTMLCanvasElement | OffscreenCanvas;
	}) => import("@babylonjs/core").Engine;
	createCanvas: ({ width, height, }: {
		width: number;
		height: number;
	}) => HTMLCanvasElement;
	renderOnce: (scene: import("@babylonjs/core").Scene) => Promise<void>;
	v3: typeof v3;
	c3: (color: string) => import("@babylonjs/core").Color3;
	c4: (color: string) => import("@babylonjs/core").Color4;
	describeMesh: (mesh: import("@babylonjs/core").AbstractMesh, search?: RegExp, depth?: number) => void;
	helloWorld: (engine?: import("@babylonjs/core").Engine) => import("@babylonjs/core").Scene;
	attachEditorControls: (camera: import("@babylonjs/core").ArcRotateCamera, options?: Partial<{
		keySensitivity: number;
		mouseSensitivity: number;
		parent: HTMLElement;
		action: () => void;
	}>) => AnimateState[];
};
export type ModelPath = string | File | string[] | File[];
export type ModelBuilder = {
	lock: (id?: string) => Promise<string>;
	unlock: (id: string) => ModelBuilder;
	camera: (x: number, y: number, z: number) => ModelBuilder;
	lookAt: (x: number, y: number, z: number) => ModelBuilder;
	takeCanvas: (width?: number, height?: number) => Promise<HTMLCanvasElement>;
	attachControls: () => ModelBuilder;
	startRenderLoop: () => ModelBuilder;
	reset: () => ModelBuilder;
	describe: (what?: string, search?: RegExp) => ModelBuilder;
	updateColor: (color: string, texture?: RegExp, mesh?: RegExp) => ModelBuilder;
	updateTranslucency: (value: number, texture?: RegExp, mesh?: RegExp) => ModelBuilder;
	gotoFrame: (frame: number) => Promise<void>;
	morph: (influences: Record<string, number>) => ModelBuilder;
	fix: (mapper: ModelMeshMapper) => ModelBuilder;
	fixMesh: (mesh: ModelMesh, mapper: ModelMeshMapper) => ModelBuilder;
	fixMaterial: (mesh: ModelMesh, mapper: ModelMaterialMapper) => ModelBuilder;
	fixTexture: (material: ModelMaterial, mapper: ModelTextureMapper) => ModelBuilder;
	color3: (value: string) => Color3;
	color4: (value: string) => Color4;
	append: (path: ModelPath, name?: string) => Promise<ModelBuilder>;
	createTexture: (image: HTMLCanvasElement | HTMLImageElement) => Promise<ModelTexture>;
	getMorphs: (search?: RegExp) => string[];
	addMorphRemaps: (remaps: MorphRemaps) => ModelBuilder;
	getModelNames: () => string[];
	setClearColor: (color: string) => ModelBuilder;
	setRotation: (model: string, radians: number) => ModelBuilder;
	getBBox: (model: string) => BoundingBox;
	wireframe: () => ModelBuilder;
	pickMesh: (x: number, y: number, predicate?: (mesh: ModelMesh) => boolean) => Nullable<ModelMesh> | undefined;
	highlight: (mesh: ModelMesh, color: string) => ModelBuilder;
	unHighlight: (mesh?: ModelMesh) => ModelBuilder;
	addTestCube: () => ModelBuilder;
	render: () => ModelBuilder;
};
export type MorphRemaps = Record<string, string[]>;
export type ModelMesh = AbstractMesh;
export type ModelConcreteMesh = Mesh;
export type ModelNode = Node;
export type ModelMaterial = PBRMaterial;
export type ModelTexture = Texture;
export type ModelColor3 = Color3;
export type ModelColor4 = Color4;
export type ModelBoundingBox = BoundingBox;
export type ModelMeshMapper = (mesh: ModelMesh) => ModelMesh;
export type ModelMaterialMapper = (material: ModelMaterial) => ModelMaterial;
export type ModelTextureMapper = (texture: ModelTexture) => ModelTexture;
export declare const Models: {
	renderOnce: (scene: import("@babylonjs/core").Scene) => Promise<void>;
	loadDazFigure: (props: {
		path: string | File;
		scene: import("@babylonjs/core").Scene;
		name?: string;
	}) => Promise<import("@babylonjs/core").AbstractMesh>;
	fixDazFigure: (scene: import("@babylonjs/core").Scene) => void;
	loadAssetContainer: (scene: import("@babylonjs/core").Scene, path: string | File, options?: Partial<{
		onProgress: (event: import("@babylonjs/core").ISceneLoaderProgressEvent) => void;
	}>) => Promise<import("@babylonjs/core").AssetContainer>;
	builder: (props?: {
		scene?: import("@babylonjs/core").Scene;
		path?: ModelPath;
		exposure?: number;
		toneMappingEnabled?: boolean;
		addDefaultLights?: boolean;
		clearColor?: string;
	}) => Promise<ModelBuilder>;
};
declare const TEXTURE_SAMPLING_MODES: {
	linearNearest: number;
	nearestNearest: number;
	linearLinear: number;
	nearestLinear: number;
};
export type ImmediateImage = HTMLCanvasElement | HTMLImageElement | OffscreenCanvas;
export type TextureImageSrc = string | ImmediateImage;
export type TextureLayer = Partial<{
	image: TextureImageSrc;
	color: string;
	size: number;
	_texture: ModelTexture;
	_mesh: ModelMesh;
	_material: StandardMaterial;
	_cached: boolean;
}>;
export type TextureBuilder = {
	addLayer: (layer: TextureLayer) => TextureBuilder;
	render: () => Promise<HTMLCanvasElement | OffscreenCanvas>;
	clear: () => TextureBuilder;
};
export type TextureSamplingModeMap = typeof TEXTURE_SAMPLING_MODES;
export type TextureOptions = Partial<{
	hasAlpha: boolean;
	generateMipMaps: boolean;
	samplingMode: keyof TextureSamplingModeMap;
}>;
export type HtmlElementTextureOptions = Partial<TextureOptions & {
	element: HTMLCanvasElement | HTMLVideoElement;
}>;
export type PathTextureOptions = Partial<TextureOptions & {
	src: string;
}>;
export type DynamicTextureOptions = Partial<TextureOptions & {
	width: number;
	height: number;
	init: (ctx: ICanvasRenderingContext) => void;
}>;
export type AllTextureOptions = HtmlElementTextureOptions & DynamicTextureOptions;
export declare const Textures: {
	builder: ({ size }?: {
		size: number;
	}) => TextureBuilder;
	copyToCanvas: (image: HTMLCanvasElement | OffscreenCanvas | HTMLImageElement, width?: number, height?: number) => HTMLCanvasElement;
	debugImage: (image: HTMLCanvasElement | HTMLImageElement, label?: string) => Promise<unknown>;
	getTexture: <T extends import("@babylonjs/core").BaseTexture>(scene: import("@babylonjs/core").Scene, name: string, producer: () => T) => T;
	getHtmlElementTexture: (scene: import("@babylonjs/core").Scene, name: string, options: HtmlElementTextureOptions) => import("@babylonjs/core").HtmlElementTexture;
	getDynamicTexture: (scene: import("@babylonjs/core").Scene, name: string, options?: DynamicTextureOptions) => import("@babylonjs/core").DynamicTexture;
	getPathTexture: (scene: import("@babylonjs/core").Scene, name: string, options: PathTextureOptions) => import("@babylonjs/core").Texture;
	updateTexture: (texture: import("@babylonjs/core").BaseTexture, options: AllTextureOptions) => void;
	imageToTexture: (scene: import("@babylonjs/core").Scene, name: string, image: string | HTMLImageElement | HTMLCanvasElement | OffscreenCanvas) => Promise<import("@babylonjs/core").Texture>;
	drawTextOnTexture: (texture: import("@babylonjs/core").DynamicTexture, text: string, options?: Partial<{
		color: string;
		outline: boolean;
		outlineColor: string;
		backgroundColor: string;
		text: string;
		textureSize: number;
		textScale: number;
		rotation: Point3;
		fontFamily: string;
		fontStyle: string;
	}>) => {
		x: number;
		y: number;
		width: number;
		height: number;
	};
	drawOnTexture: (texture: import("@babylonjs/core").DynamicTexture, render: (ctx: ICanvasRenderingContext, size: {
		width: number;
		height: number;
	}) => void) => void;
	drawBackgroundOnTexture: (texture: import("@babylonjs/core").DynamicTexture, options?: Partial<{
		color: string;
	}>) => void;
	clearTexture: (texture: import("@babylonjs/core").DynamicTexture) => void;
	destroyTexture: (scene: import("@babylonjs/core").Scene, name: string) => void;
};
export declare const CAMERA_MODES: {
	orthographic: number;
	perspective: number;
};
export type CameraModeMap = typeof CAMERA_MODES;
export type CameraOptions = Partial<{
	mode: keyof CameraModeMap;
	position: Vec3;
	minZ: number;
	maxZ: number;
	target: Vec3;
	orthoTop: number;
	orthoBottom: number;
	orthoLeft: number;
	orthoRight: number;
}>;
export type ArcRotateCameraOptions = Partial<CameraOptions & {
	alpha: number;
	beta: number;
	radius: number;
}>;
export type UniversalCameraOptions = Partial<CameraOptions & {
	rotation: Vec3;
}>;
export type AllCameraOptions = ArcRotateCameraOptions & UniversalCameraOptions;
export declare const Cameras: {
	getArcRotateCamera: (scene: import("@babylonjs/core").Scene, name: string, options?: ArcRotateCameraOptions) => import("@babylonjs/core").ArcRotateCamera;
	getCamera: <T extends Camera>(scene: import("@babylonjs/core").Scene, name: string, producer: () => T) => T;
	updateCamera: (camera: Camera, options: AllCameraOptions) => void;
	getUniversalCamera: (scene: import("@babylonjs/core").Scene, name: string, options?: UniversalCameraOptions) => import("@babylonjs/core").UniversalCamera;
	attachArcRotateCameraControls: (camera: import("@babylonjs/core").ArcRotateCamera, options?: Partial<{
		keySensitivity: number;
		mouseSensitivity: number;
		parent: HTMLElement;
		action: () => void;
	}>) => AnimateState[];
	attachUniversalCameraControls: (camera: import("@babylonjs/core").UniversalCamera, options?: Partial<{
		keySensitivity: number;
		mouseSensitivity: number;
		parent: HTMLElement;
	}>) => void;
	createTopDownCamera: (scene: import("@babylonjs/core").Scene, name: string, { unitsTall, unitsWide, height, disposeActive, }?: Partial<{
		height: number;
		disposeActive: boolean;
		unitsTall: number;
		unitsWide: number;
	}>) => import("@babylonjs/core").UniversalCamera;
	createDebugCamera: (scene: import("@babylonjs/core").Scene, name: string) => void;
};
export declare const Layers: {
	getGlowLayer: (scene: import("@babylonjs/core").Scene, name: string, options?: import("@babylonjs/core").IGlowLayerOptions) => import("@babylonjs/core").GlowLayer;
	getHighlightLayer: <T extends import("@babylonjs/core").HighlightLayer>(scene: import("@babylonjs/core").Scene, name: string, options?: import("@babylonjs/core").IHighlightLayerOptions) => import("@babylonjs/core").HighlightLayer;
};
export type LightOptions = Partial<{
	intensity: number;
}>;
export type HemisphericLightOptions = Partial<LightOptions & {
	direction: Vec3;
}>;
export type PointLightOptions = Partial<LightOptions & {
	position: Vec3;
}>;
export type AllLightOptions = LightOptions & HemisphericLightOptions & PointLightOptions;
export declare const Lights: {
	getLight: <T extends import("@babylonjs/core").Light>(scene: import("@babylonjs/core").Scene, name: string, producer: () => T) => T;
	getHemisphericLight: (scene: import("@babylonjs/core").Scene, name: string, options?: HemisphericLightOptions) => import("@babylonjs/core").HemisphericLight;
	getPointLight: (scene: import("@babylonjs/core").Scene, name: string, options?: PointLightOptions) => import("@babylonjs/core").PointLight;
	updateLight: (light: import("@babylonjs/core").Light, options: AllLightOptions) => void;
};
export type MaterialTypeMap = {
	standard: StandardMaterial;
	pbr: PBRMaterial;
};
export type MaterialOptions = Partial<{
	type: keyof MaterialTypeMap;
}>;
export type StandardMaterialOptions = Partial<MaterialOptions & {
	diffuseTexture: string;
	emissiveTexture: string;
	ambientTexture: string;
	opacityTexture: string;
	diffuseColor: string;
	alpha: number;
	specularColor: string;
	ambientColor: string;
	emissiveColor: string;
}>;
export type PbrMaterialOptions = Partial<{}>;
export type AllMaterialOptions = StandardMaterialOptions & PbrMaterialOptions;
export declare const Materials: {
	getMaterial: <T extends keyof MaterialTypeMap = keyof MaterialTypeMap>(scene: import("@babylonjs/core").Scene, name: string, options?: T | AllMaterialOptions) => MaterialTypeMap[T];
	updateMaterial: (scene: import("@babylonjs/core").Scene, material: import("@babylonjs/core").Material, options: AllMaterialOptions) => void;
	updateStandardMaterial: (scene: import("@babylonjs/core").Scene, material: import("@babylonjs/core").StandardMaterial, options: AllMaterialOptions) => void;
};
export type MeshOptions = Partial<{
	position: Point3 | Point2;
	color: string;
	material: string;
	receiveShadows: boolean;
}>;
export type BoxOptions = Partial<{
	width: number;
	height: number;
	depth: number;
	colors: string[];
}>;
declare const BabPolyMap: {
	tetrahedron: number;
	octahedron: number;
	dodecahedron: number;
	icosahedron: number;
	rhombicuboctahadron: number;
	triangularPrism: number;
	pentagonalPrism: number;
	hexagonalPrism: number;
	squarePyramid: number;
	pentagonalPyramid: number;
	triangularDipyramid: number;
	pentagonalDipryramid: number;
	elongatedSquareDipyramid: number;
	elongatedPentagonalDipyramid: number;
	elongatedPentagonalCupola: number;
};
export declare const Meshes: {
	lookAt: (from: Point2, to: Point2) => number;
	getBox: (scene: import("@babylonjs/core").Scene, name: string, options?: MeshOptions & BoxOptions) => import("@babylonjs/core").Mesh;
	getPlane: (scene: import("@babylonjs/core").Scene, name: string, options?: MeshOptions & Partial<{
		width: number;
		height: number;
		tag: string | string[];
		billboard: boolean;
	}>) => import("@babylonjs/core").Mesh;
	getBoxInstance: (scene: import("@babylonjs/core").Scene, name: string, options: MeshOptions & Partial<{
		width: number;
		height: number;
		depth: number;
		receiveShadows: boolean;
	}>) => import("@babylonjs/core").InstancedMesh;
	getSphere: (scene: import("@babylonjs/core").Scene, name: string, options: MeshOptions & Partial<{
		radius: number;
	}>) => import("@babylonjs/core").Mesh;
	getCylinder: (scene: import("@babylonjs/core").Scene, name: string, options?: MeshOptions & Partial<{
		height: number;
		arc: number;
		radius: number;
		tag: string | string[];
	}>) => import("@babylonjs/core").Mesh;
	getTorusKnot: (scene: import("@babylonjs/core").Scene, name: string, options?: MeshOptions & Partial<{
		radius: number;
		material: string;
	}>) => import("@babylonjs/core").Mesh;
	getLine: (scene: import("@babylonjs/core").Scene, name: string, options: MeshOptions & Partial<{
		points: Point3[];
		colors: string[];
		updatable: boolean;
		useVertexAlpha: boolean;
	}>) => import("@babylonjs/core").LinesMesh;
	walkMeshes: (mesh: import("@babylonjs/core").AbstractMesh | import("@babylonjs/core").Scene, walker: (mesh: import("@babylonjs/core").AbstractMesh) => void) => void;
	pickMesh: (scene: import("@babylonjs/core").Scene, x: number, y: number, options?: Partial<{
		camera: import("@babylonjs/core").Camera;
		predicate: (mesh: import("@babylonjs/core").AbstractMesh) => boolean;
	}>) => import("@babylonjs/core").Nullable<import("@babylonjs/core").AbstractMesh> | undefined;
	getMesh: <T extends import("@babylonjs/core").Mesh | import("@babylonjs/core").InstancedMesh>(scene: import("@babylonjs/core").Scene, name: string, producer: (instance?: T) => T, updatable?: boolean) => T;
	getMeshAsync: <T extends import("@babylonjs/core").Mesh | import("@babylonjs/core").InstancedMesh>(scene: import("@babylonjs/core").Scene, name: string, producer: () => Promise<T>) => Promise<T>;
	calcTopOfMeshWorldPosition: (mesh: import("@babylonjs/core").AbstractMesh) => Point3;
	mergeMeshes: (meshes: import("@babylonjs/core").Mesh[], options?: Partial<{
		disposeSource: boolean;
		allow32BitsIndices: boolean;
		meshSubclass: import("@babylonjs/core").Mesh;
		subdivideWithSubMeshes: boolean;
		multiMultiMaterials: boolean;
	}>) => import("@babylonjs/core").Nullable<import("@babylonjs/core").Mesh>;
	getVoxModel: (scene: import("@babylonjs/core").Scene, name: string, src: string, options?: MeshOptions & Partial<{
		merged: boolean;
	}>) => import("@babylonjs/core").SolidParticleSystem;
	calcClientRectForMesh: (mesh: import("@babylonjs/core").AbstractMesh) => {
		width: number;
		height: number;
		left: number;
		top: number;
		right: number;
		bottom: number;
	};
	updateArcRotateCameraPosition: (camera: import("@babylonjs/core").ArcRotateCamera, position: Point3) => void;
	findClosestPick: (picks: import("@babylonjs/core").PickingInfo[]) => import("@babylonjs/core").PickingInfo | undefined;
	destroyMesh: (scene: import("@babylonjs/core").Scene, name: string, options?: Partial<{
		recurse: boolean;
		disposeMaterials: boolean;
		disposeTextures: boolean;
	}>) => void;
	getMeshInstance: <T extends import("@babylonjs/core").Mesh>(scene: import("@babylonjs/core").Scene, name: string, rootName: string, producer: () => T) => import("@babylonjs/core").InstancedMesh;
	getMeshInstanceAsync: <T extends import("@babylonjs/core").Mesh>(scene: import("@babylonjs/core").Scene, name: string, rootName: string, producer: () => Promise<T>) => Promise<import("@babylonjs/core").InstancedMesh>;
	isInstancedMesh: (mesh: import("@babylonjs/core").AbstractMesh) => mesh is import("@babylonjs/core").InstancedMesh;
	pickMeshes: (scene: import("@babylonjs/core").Scene, x: number, y: number, options?: Partial<{
		camera: import("@babylonjs/core").Camera;
		predicate: (mesh: import("@babylonjs/core").AbstractMesh) => boolean;
	}>) => import("@babylonjs/core").Nullable<import("@babylonjs/core").PickingInfo[]>;
	getPolyhedron: (scene: import("@babylonjs/core").Scene, name: string, options?: MeshOptions & Partial<{
		size: number;
		type: keyof typeof BabPolyMap;
		material: string;
	}>) => import("@babylonjs/core").Mesh;
	updateMesh: (scene: import("@babylonjs/core").Scene, mesh: import("@babylonjs/core").Mesh | import("@babylonjs/core").InstancedMesh, options: MeshOptions) => void;
};
export declare const Nodes: {
	getTransformNode: (scene: import("@babylonjs/core").Scene, name: string) => import("@babylonjs/core").TransformNode;
};
export type SpsOptions = Partial<{
	useModelMaterial: boolean;
}>;
export declare const getParticleSystem: <T extends IParticleSystem | SolidParticleSystem>(scene: Scene, name: string, producer: () => T) => T;
export declare const getSolidParticleSystem: (scene: Scene, name: string, options?: SpsOptions) => SolidParticleSystem;
export declare const Particles: {
	getSolidParticleSystem: (scene: Scene, name: string, options?: SpsOptions) => SolidParticleSystem;
};
export declare const Rays: {
	createRay: (origin: Point3, direction: Point3, length?: number) => import("@babylonjs/core").Ray;
	pickWithRay: (scene: import("@babylonjs/core").Scene, ray: import("@babylonjs/core").Ray, options?: Partial<{
		predicate: (mesh: import("@babylonjs/core").AbstractMesh) => boolean;
		fastCheck: boolean;
		trianglePredicate: import("@babylonjs/core").TrianglePickingPredicate;
	}>) => import("@babylonjs/core").Nullable<import("@babylonjs/core").PickingInfo>;
};
export declare const createScene: (engine: Engine) => Scene;
export declare const Scenes: {
	createScene: (engine: Engine) => Scene;
	toggleInspector: (scene: Scene) => void;
};
export declare const Shadows: {
	addShadowToMesh: (mesh: import("@babylonjs/core").Mesh | import("@babylonjs/core").InstancedMesh) => () => void;
};
export declare const addGlowLayer: (scene: Scene, name: string, options?: Partial<IGlowLayerOptions>) => GlowLayer;
export declare const Specials: {
	addGlowLayer: (scene: Scene, name: string, options?: Partial<IGlowLayerOptions>) => GlowLayer;
	Constants: typeof Constants;
};
export type SpriteManagerOptions = Partial<{
	capacity: number;
	cellSize: {
		width: number;
		height: number;
	} | number;
	imgUrl: string;
}>;
export declare const getSpriteManager: (scene: Scene, name: string, options?: SpriteManagerOptions) => import("@babylonjs/core/Sprites/spriteManager").ISpriteManager | SpriteManager;
export declare const getSprite: (scene: Scene, name: string, spriteManagerName: string) => Sprite;
export declare const Sprites: {
	getSpriteManager: (scene: Scene, name: string, options?: SpriteManagerOptions) => import("@babylonjs/core/Sprites/spriteManager").ISpriteManager | SpriteManager;
	getSprite: (scene: Scene, name: string, spriteManagerName: string) => Sprite;
};
export type NextRandom = {
	(): number;
};
export type MinMax = [
	number,
	number
];
export declare const seedRandom: (seed: number) => NextRandom;
declare function randomUuid(random?: NextRandom): string;
export type RandomIntegerConfig = {
	minMax: MinMax;
	random: NextRandom;
};
declare function randomInteger(config?: Partial<RandomIntegerConfig>): number;
declare function pickRandom<T>(oneOrMany: T | Array<T> | Readonly<Array<T>>, nextRandom?: NextRandom): T;
declare function pickRandomNeighbors(sourceArray: Array<any>, count: number, nextRandom?: NextRandom): any[];
declare function shuffle<T>(oneOrMany: T | Array<T>, random?: NextRandom): Array<T>;
export declare const Randoms: {
	seedRandom: (seed: number) => NextRandom;
	globalRandom: NextRandom;
	randomInteger: typeof randomInteger;
	randomUuid: typeof randomUuid;
	pickRandom: typeof pickRandom;
	pickRandoms: <T>({ from, count, nextRandom, random, forceUnique, }: {
		from: T | T[] | readonly T[];
		count: number;
		nextRandom?: NextRandom;
		random?: NextRandom;
		forceUnique?: boolean;
	}) => T[];
	pickRandomNeighbors: typeof pickRandomNeighbors;
	shuffle: typeof shuffle;
	integerRangeStream: (random: NextRandom) => (max?: number, min?: number) => number;
};
export type XYZ = {
	x: number;
	y: number;
	z: number;
};
export type XYZI = {
	x: number;
	y: number;
	z: number;
	i: number;
};
export type TRN = {
	node_id: number;
	attributes: object;
	child_id: number;
	reserved_id: number;
	number_of_frames: number;
	frame_transforms: object[];
};
export type GRP = {
	id: number;
	attributes: object;
	num_of_children: number;
	child_ids: number[];
};
export type SHP = {
	id: number;
	attributes: object;
	num_of_models: number;
	models: {
		id: number;
		attributes: object;
	}[];
};
export type LAYR = {
	id: number;
	attributes: object;
	reserved_id: number;
};
/** range: 0-255 */
export type RGBA = {
	r: number;
	g: number;
	b: number;
	a: number;
};
/** key is a number in string format */
export type MATL = {
	id: number;
	properties: Record<string, number>;
};
/** key is a number in string format */
export type OBJ = Record<string, number>;
/** reverse engineered, this is NOT definitive :) */
export type VoxData = {
	VOX: number;
	SIZE: XYZ;
	XYZI: XYZI[];
	nTRN: TRN[];
	nGRP: GRP[];
	nSHP: SHP[];
	LAYR: LAYR[];
	RGBA: RGBA[];
	MATL: MATL[];
	rOBJ: OBJ[];
};
export declare const Voxels: {
	animateExplosion: (particle: import("@babylonjs/core").SolidParticle, options?: Partial<{
		random: NextRandom;
		radius: number;
		maxBounce: number;
		groundZ: number;
		speed: number;
		decay: number;
		dispose: () => void;
	}>) => void;
	voxDataToSps: (scene: import("@babylonjs/core").Scene, voxData: VoxData, name: string) => import("@babylonjs/core").SolidParticleSystem;
	voxDataToMergedModel: (scene: import("@babylonjs/core").Scene, voxData: VoxData, name: string) => import("@babylonjs/core").Mesh;
	voxDataToComplexModel: (scene: import("@babylonjs/core").Scene, voxData: VoxData, name: string) => import("@babylonjs/core").Mesh;
};
declare function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string;
export type EventualByteLike = Blob;
export type ImmediateByteLike = string | ArrayBuffer | ArrayBufferView | unknown[];
declare function toBase64(bytes: EventualByteLike): Promise<string>;
declare function toBase64(bytes: ImmediateByteLike): string;
export type ADDRESS_ALGORITHM = "SHA-512" | "SHA-256";
export declare const Bytes: {
	toMsgPack: <T>(obj: T) => Uint8Array;
	msgPackToObject: <T_1>(bytes: ArrayLike<number>) => T_1;
	typeOfBytes: (bytes: unknown) => "Blob" | "ArrayBuffer" | "string" | "ArrayBufferView" | "Array" | undefined;
	toDataUrl: (bytes: ByteLike) => Promise<string>;
	dataUrlToBlob: (dataUrl: string) => Blob | undefined;
	lengthOf: (bytes: ByteLike) => number | undefined;
	isByteLike: (maybe: unknown) => maybe is ByteLike;
	isImmediateByteLike: (maybe: unknown) => maybe is ImmediateByteLike;
	hashOf: ({ bytes, algorithm, }: {
		algorithm?: ADDRESS_ALGORITHM | undefined;
		bytes: ByteLike;
	}) => Promise<ArrayBuffer>;
	immediateHashOf: (bytes: ImmediateByteLike, algorithm: ADDRESS_ALGORITHM) => Promise<ArrayBuffer>;
	addressStringOf: ({ bytes, algorithm, radix, }: {
		algorithm?: ADDRESS_ALGORITHM | undefined;
		bytes: ByteLike;
		radix?: number | undefined;
	}) => Promise<string>;
	toArrayBuffer: (bytes: ByteLike) => Promise<ArrayBuffer>;
	immediateToArrayBuffer: (bytes: ImmediateByteLike) => ArrayBuffer;
	toBlob: (bytes: ByteLike, mediaType?: string) => Blob;
	toText: (bytes: ByteLike) => Promise<string>;
	toBase64: typeof toBase64;
	encodeAsString: (bytes: ByteLike, radix?: number) => Promise<string>;
	test: () => Promise<boolean>;
	assignMediaTypeToBlob: <MT extends string>(blob: Blob, mediaType: MT) => Blob & {
		type: MT;
	};
	utf8ToUint8Array: (input: string) => Uint8Array;
	base64ToArrayBuffer: (input: string) => ArrayBuffer;
	arrayBufferToHex: (input: ArrayBuffer) => string;
	arrayBufferToUtf8: (input: ArrayBuffer) => string;
	arrayBufferToBase64: typeof arrayBufferToBase64;
	ALL_ALGORITHMS: ADDRESS_ALGORITHM[];
	ALGORITHM_BYTE_LENGTHS: {
		"SHA-512": number;
		"SHA-256": number;
	};
};
export type ByteLike = EventualByteLike | ImmediateByteLike;
export type Brand<K, T> = K & {
	__brand: T;
};
export type ErrorLike = {
	message?: string;
	cause?: unknown;
	stack?: string;
};
export type Nullable<T> = T | undefined | null;
export type Producer<T> = () => T;
export type ValueProducer<T> = T | Producer<T>;
export type TypeGuard<T> = (maybe: unknown) => maybe is T;
export declare const Arrays: {
	from: <T>(value?: number | ArrayLike<T> | Iterable<T>) => T[];
};
declare function times<T>(count: number, mapper: (index: number, stop: () => void) => T): T[];
declare function timesGen<T>(count: number, mapper: (index: number, stop: () => void) => T): Generator<T>;
declare function isIterable<T>(maybe: unknown): maybe is Iterable<T>;
export type JSONValue = string | number | boolean | null | JSONObject | JSONArray;
export type JSONObject = {
	[key: string]: JSONValue;
};
export type JSONArray = JSONValue[];
declare function parseIncompleteJson(input: string): JSONValue | undefined;
export type Tuple0 = [
];
export type Tuple1<A> = [
	A
];
export type Tuple2<A, B> = [
	A,
	B
];
export type Tuple3<A, B, C> = [
	A,
	B,
	C
];
export type Tuple4<A, B, C, D> = [
	A,
	B,
	C,
	D
];
export type Tuple5<A, B, C, D, E> = [
	A,
	B,
	C,
	D,
	E
];
export declare const Objects: {
	isErrorLike: (maybe: unknown) => maybe is ErrorLike;
	orError: <T>(f: () => T, options?: Partial<{
		message?: string;
		cause?: unknown;
	}>) => T | Error;
	tryValue: <T>(value: T | Error, message?: string) => T;
	isErrorType: (value: unknown) => value is Error;
	isEmpty: (value?: string | boolean | number | undefined) => boolean;
	isNotEmpty: (value?: string | boolean | number | undefined) => boolean;
	isIterator: <T>(maybe: unknown) => maybe is Iterator<T>;
	isArrayLike: <T>(maybe: unknown) => maybe is ArrayLike<T>;
	times: typeof times;
	first: <O, T extends O>(obj: Readonly<O[] | O | Iterator<O, T>>, typeGuard?: TypeGuard<T>) => T | undefined;
	last: <T>(obj: Readonly<T[]>) => T | undefined;
	fix: <T>(v: T) => Fixed<T> | undefined;
	iff: <T, R>(value: T, mapper: (v: NonNullable<T>) => R) => R | undefined;
	iffTyped: <T, R, G>(typeGuard: (maybe: unknown) => maybe is G, value: T, mapper: (v: T & G) => R) => R | undefined;
	includesUndefined: (...arr: unknown[]) => true | undefined;
	isDefined: <T>(obj: T | undefined | null) => obj is NonNullable<T>;
	isUndefined: <T>(obj: T | undefined | null) => obj is undefined;
	omit: <K extends string | number, T extends {
		[k in K]: unknown;
	}>(object: T, key: K) => Omit<T, K>;
	omitUnsafe: <K extends string | number, T extends {
		[k in K]: unknown;
	}>(object: T, key: K) => Omit<T, K>;
	orElse: <T>(o: T, e: T) => T;
	removeUndefinedValues: <T extends object>(obj: object) => Partial<T>;
	toMany: <T>(obj: T | T[] | Iterable<T>) => T[];
	set: <O extends object, K extends keyof O = keyof O, V extends O[K] = O[K]>(obj: O, key: K, value: V) => O & {
		[k in K]: V;
	};
	setUnsafe: <O extends object, K extends keyof O = keyof O, V extends O[K] = O[K]>(obj: O, key: K, value: V) => O & {
		[k in K]: V;
	};
	get: <O extends object, K extends keyof O = keyof O>(obj: O, key: K, defaultValue?: O[K] | undefined) => O[K] | undefined;
	update: <O extends object, K extends keyof O>(obj: O, key: K, mapper: (value: O[K]) => O[K]) => O;
	updateUnsafe: <O extends object, K extends keyof O>(obj: O, key: K, mapper: (value: O[K]) => O[K]) => O;
	entries: <O extends object, K extends keyof O, V = O[K]>(obj: O) => [
		K,
		V
	][];
	keys: <O extends object, K extends keyof O>(obj: O) => K[];
	values: <O extends object, V = O[keyof O]>(obj: O) => V[];
	forEach: <O extends object, K extends keyof O>(obj: O, consumer: (key: K, value: O[K]) => void, errorHandler?: (error: unknown, key: K, value: O[K]) => void) => void;
	filter: <O extends object, K extends keyof O, V extends O[K]>(obj: O, predicate: (key: K, value: V) => boolean) => [
		K,
		V
	][];
	chain: <T>(initial: T, mappers: ((v: T) => T)[]) => T;
	fromEntries: <K extends string | number | symbol, V>(entries: readonly (readonly [
		K,
		V
	])[]) => Record<K, V>;
	fromEntriesToMultimap: <K extends string | number | symbol, V>(entries: [
		K,
		V
	][]) => Record<K, V[]>;
	freeze: <T>(v: T) => Readonly<T | undefined>;
	hasKey: (obj: Record<string, any>, key: string | string[]) => boolean;
	tuple0: () => [
	];
	tuple1: <A>(a: A) => Tuple1<A>;
	tuple2: <A, B>(a: A, b: B) => Tuple2<A, B>;
	tuple3: <A, B, C>(a: A, b: B, c: C) => Tuple3<A, B, C>;
	tuple4: <A, B, C, D>(a: A, b: B, c: C, d: D) => Tuple4<A, B, C, D>;
	tuple5: <A, B, C, D, E>(a: A, b: B, c: C, d: D, e: E) => Tuple5<A, B, C, D, E>;
	safe: <R>(producer: () => R, options?: Partial<{
		quiet: boolean;
		def: R;
		onError: ValueProducer<string>;
	}>) => R | undefined;
	safeAsync: <R>(producer: () => Promise<R> | R, options?: Partial<{
		quiet: boolean;
		def: R;
		onError: ValueProducer<string>;
	}>) => Promise<R | undefined>;
	valueOf: <T>(valueProducer: ValueProducer<T>) => T;
	mapValue: <T, R>(value: T, mapper: (value: T) => R) => R;
	headOf: <O, T extends O>(obj: Readonly<O[] | O | Iterator<O, T>>, typeGuard?: TypeGuard<T>) => T | undefined;
	tailOf: <O>(obj: O[]) => O[] | undefined;
	restOf: <O>(obj: O[]) => O[] | undefined;
	toMultiMap: <K extends string | number, T>(maps: Record<K, T>[], options?: Partial<{
		compact: boolean;
	}>) => Record<K, T[]>;
	timesGen: typeof timesGen;
	isIterable: typeof isIterable;
	isBrowser: () => boolean;
	iffBrowser: <T>(producer: () => T) => T | undefined;
	mapOf: <K extends string | number | symbol, V, R>(obj: Record<K, V>, mapper: (key: K, value: V) => R) => R[];
	toPromise: <T>(producer: (callback: () => void) => T) => Promise<T>;
	all: {
		<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>;
		<T extends readonly unknown[] | [
		]>(values: T): Promise<{
			-readonly [P in keyof T]: Awaited<T[P]>;
		}>;
	};
	isFunction: (maybe: unknown) => maybe is Function;
	toNumber: (value: string) => number | undefined;
	toBoolean: (value: string | undefined) => boolean;
	waitTimeout: (ms: number) => Promise<unknown>;
	createSettler: <T>({ settleAction, settledAfterMs, }: {
		settledAfterMs: number;
		settleAction: (value: T) => unknown;
	}) => {
		update: (value: T) => void;
	};
	parseIncompleteJson: typeof parseIncompleteJson;
};
export type FixedBrand<T = unknown> = Brand<T, "Fixed">;
export type Fixed<T = unknown> = Readonly<FixedBrand<T>>;
export declare const Fixes: {
	fix: <T>(v: T) => Fixed<T> | undefined;
	extend: <T>(arr: T[], value: T) => Fixed<T[]> | undefined;
	replace: <T, A, R>(typeGuard: TypeGuard<T>, arr: A[], mapper: (v: T) => R) => (R | A)[] | undefined;
};
export type FixedArray<T> = Fixed<T[]> | Fixed<Fixed<T[]>> | Fixed<Fixed<T>[]>;
export declare const Keys: {
	stableStringify: typeof stableStringify;
};
export type TypeInfo<T> = {
	type: T;
	typeDeclaration: string;
	validate: (data: unknown) => boolean;
	schema: TypeInfoSchema;
};
export type TypeInfoSchema = TSchema;
export declare const TypeBoxes: {
	createTypeInfo: <T extends TSchema>(schemaBuilder: (type: import("@sinclair/typebox").JavaScriptTypeBuilder) => T) => TypeInfo<import("@sinclair/typebox").Static<T>>;
	schemaToTypeInfo: (schema: TSchema) => {
		type: unknown;
		typeDeclaration: string;
		validate: (data: unknown) => boolean;
		schema: TSchema;
	};
	schemaToAnyOfs: (schema: TSchema | undefined) => string[];
	typeTextToSchema: (typeText: string) => TSchema;
};
export declare const BrowserFiles: {
	readFileBrowser: (path: string) => Promise<Fil>;
	writeFileBrowser: (path: string, data: ByteLike) => void;
	mediaTypeOfPath: (path: string) => string;
	baseMediaTypeOf: (mediaType: string) => string;
	openFileHandle: (options: FilePickerOptions & {
		multiple: boolean;
	}) => Promise<FileSystemFileHandle[]>;
	openDirectoryHandle: (options: DirectoryPickerOptions & {
		multiple: boolean;
	}) => Promise<FileSystemDirectoryHandle>;
	listFiles: (dir: FileSystemDirectoryHandle) => Promise<FilenameHandle[]>;
	pathToParts: (path: string) => string[];
	pathToFilename: (path: string) => string;
	pathToFilenameAndFolders: (path: string) => Tuple2<string, string[]>;
};
export type Fil = {
	data: Blob;
	name: string;
};
export type RuntimeType = "node" | "browser";
export type FilenameHandle = [
	string,
	FileSystemHandle
];
export type Key = string | number;
export type Cache<T> = {
	set: (key: Key, value: T) => Cache<T>;
	get: (key: Key | undefined, producer?: () => T) => T | undefined;
	delete: (key: Key) => boolean;
	entries: () => [
		Key,
		T
	][];
	findKeys: (value: T) => Key[];
	clear: () => void;
	lastUpdate: () => number;
};
export declare const Caches: {
	create: <T>(name?: string) => Cache<T>;
};
export type ColorLike = ColorBuilder | string | Color3 | Color4;
export type ColorModel = "rgb" | "rgba" | "hsl" | "hsla";
export type Color3 = [
	number,
	number,
	number
];
export type Color4 = [
	number,
	number,
	number,
	number
];
export type ColorBuilder = QixColor;
export type ColorOperation = "darken" | "lighten" | "random" | "rotateHue" | "opacity" | "desaturate" | "saturate" | "color";
export type ColorSpec = Partial<{
	[k in ColorOperation]: number | string;
}>;
declare function builder({ color, model, }: {
	color?: ColorLike;
	model?: ColorModel;
}): ColorBuilder;
declare function darken(color: ColorLike, ratio: number): string;
declare function desaturate(color: ColorLike, ratio: number): string;
declare function lighten(color: ColorLike, ratio: number): string;
declare function opacity(color: ColorLike, ratio: number): string;
declare function randomColor(random?: () => number): string;
declare function rotateHue(color: ColorLike, ratio: number): string;
declare function saturate(color: ColorLike, ratio: number): string;
declare function toCssFilters({ someColor, from, }: {
	someColor: ColorLike;
	from: "white" | "black";
}): string;
declare function textColor(colors: string[], threshold?: number): string;
declare function toCss(color: ColorLike, model?: ColorModel): string;
declare function toRgbInteger(color: ColorLike): number;
export declare const Colors: {
	from: (color: ColorLike) => ColorBuilder;
	builder: typeof builder;
	toCss: typeof toCss;
	toRgbInteger: typeof toRgbInteger;
	darken: typeof darken;
	desaturate: typeof desaturate;
	lighten: typeof lighten;
	randomColor: typeof randomColor;
	saturate: typeof saturate;
	textColor: typeof textColor;
	toCssFilters: typeof toCssFilters;
	rotateHue: typeof rotateHue;
	operateOn: (spec: Partial<{
		darken: string | number;
		lighten: string | number;
		random: string | number;
		rotateHue: string | number;
		opacity: string | number;
		desaturate: string | number;
		saturate: string | number;
		color: string | number;
	}>) => string;
	opacity: typeof opacity;
	palletteFrom: (src: string | HTMLImageElement, options: {
		colorCount?: number;
		quality?: number;
	}) => Promise<never>;
};
export declare function isLut(maybe: unknown): maybe is Lut;
export type Lut = {
	s12: (numerator: number) => string;
	s12t: (numerator: number, beta?: number) => string;
	color: (alpha: number) => string;
	text: (alpha: number) => string;
};
declare function expandColors(colors: ColorBuilder[], level?: number): ColorBuilder[];
declare function create(colors: ColorLike[] | Lut, levels?: number): Lut;
export declare const Luts: {
	create: typeof create;
	expandColors: typeof expandColors;
};
export type GridObject = {
	colCount: number;
	cellWidth?: number;
	cellHeight?: number;
	spacing?: number;
};
export type GridColumnCount = number;
export declare const isGridObject: (maybe: any) => maybe is GridObject;
export type GridConfig = GridColumnCount | GridObject;
export type Cell = {
	x: number;
	y: number;
	width: number;
	height: number;
};
export type FullCell<T> = Cell & {
	value: T;
};
export type TypeGuard<T> = (maybe: any) => maybe is T;
export declare const columnCount: (grid: GridConfig) => number;
export declare const gridToGridObject: (grid: GridConfig) => GridObject;
export declare const Grids: {
	localTopLeftOf: ({ grid, cellCount, }: {
		grid: GridConfig;
		cellCount: number;
	}) => Point2;
	isOutsideOf: ({ position, grid, cellCount, }: {
		cellCount: number;
		position: Point2;
		grid: GridObject;
	}) => boolean;
	isInsideOf: (spec: {
		cellCount: number;
		position: Point2;
		grid: GridObject;
	}) => boolean;
	worldTopLeftOf: ({ position, grid, cellCount, }: {
		position: Point2;
		grid: GridConfig;
		cellCount: number;
	}) => Point2;
	worldCenterOf: ({ position, grid, cellCount, }: {
		position: Point2;
		grid: GridConfig;
		cellCount: number;
	}) => Point2;
	localCenterOf: ({ grid, cellCount, }: {
		grid: GridConfig;
		cellCount: number;
	}) => {
		x: number;
		y: number;
	};
	cellOf: ({ grid, index }: {
		index?: number;
		grid: GridConfig;
	}) => Cell;
	colOf: ({ x, grid }: {
		x: number;
		grid: GridConfig;
	}) => number;
	fullCellOf: <T>({ grid, cells, index, }: {
		grid: GridConfig;
		cells: T[];
		index: number;
	}) => FullCell<T>;
	heightOf: ({ grid, cellCount }: {
		cellCount: number;
		grid: GridConfig;
	}) => number;
	indexOf: ({ x, y, grid }: {
		x: number;
		y: number;
		grid: GridConfig;
	}) => number;
	isCell: (maybe: any) => maybe is Cell;
	isFullCell: <T_1>(maybe: any, isType: TypeGuard<T_1>) => maybe is FullCell<T_1>;
	isGridObject: (maybe: any) => maybe is GridObject;
	rowOf: ({ y, grid }: {
		y: number;
		grid: GridConfig;
	}) => number;
	valueAt: <T_2>({ x, y, grid, cells, }: {
		grid: GridConfig;
		x: number;
		y: number;
		cells: T_2[];
	}) => T_2;
	widthOf: ({ grid }: {
		grid: GridConfig;
	}) => number;
	rowCountOf: ({ grid, cellCount }: {
		cellCount: number;
		grid: GridConfig;
	}) => number;
};
export declare const Grid2s: {
	deletePoint: <T>({ grid, point }: GridPoint2<T> & {
		value: T;
	}) => void;
	nameToPoint: (name: string) => Point2;
	normalizePoint: <T_1>({ grid, point, }: GridPoint2<T_1>) => Point2;
	pointToName: (point: Point2) => string;
	setValue: <T_2>({ grid, point, value, }: GridPoint2<T_2> & {
		value: T_2;
	}) => void;
	updateValue: <T_3>({ grid, point, mapper, }: GridPoint2<T_3> & {
		mapper: (v: T_3) => T_3;
	}) => void;
	valueAt: <T_4>(gridPoint: GridPoint2<T_4>) => T_4;
};
export type Grid2<T> = Partial<{
	cellWidth: number;
	cellHeight: number;
	values: {
		[k in string]: T;
	};
}>;
export type GridPoint2<T> = {
	grid: Grid2<T>;
	point: Point2;
};
export type HtmlTagName = keyof HTMLElementTagNameMap;
export type CssStyle = Properties;
export type CreateElementSpec<K extends HtmlTagName> = Partial<{
	textContent: string;
	style: CssStyle;
	tagName: K;
	parent: HTMLElement;
	attributes: unknown;
	datasets: {
		[k in string]: string;
	};
	clazz: string;
	id: string;
}>;
declare function createElement<K extends keyof HTMLElementTagNameMap>({ tagName, parent, attributes, datasets, clazz, id, style, textContent, }: CreateElementSpec<K>): HTMLElementTagNameMap[K];
declare function readFile({ fileInput, }: {
	fileInput: HTMLInputElement;
}): Promise<ArrayLike<Blob>>;
declare function textNodesOfElement(element: HTMLElement): ChildNode[];
declare function textOfElement(element: HTMLElement): string;
export declare const Htmls: {
	textNodesOfElement: typeof textNodesOfElement;
	textOfElement: typeof textOfElement;
	createElement: typeof createElement;
	readFile: typeof readFile;
	from: <K extends keyof HTMLElementTagNameMap>(tagName?: K, options?: Partial<{
		textContent: string;
		style: CssStyle;
		tagName: K;
		parent: HTMLElement;
		attributes: unknown;
		datasets: {
			[x: string]: string;
		};
		clazz: string;
		id: string;
	}>) => HTMLElementTagNameMap[K];
	updateStyle: ({ style, element, }: {
		style?: import("csstype").Properties<0 | (string & {}), string & {}>;
		element: HTMLElement | SVGElement;
	}) => import("csstype").Properties<0 | (string & {}), string & {}>;
};
export type Idb<T = unknown> = {
	dbName: string;
	storeName: string;
};
export type IdbValidValue = ByteLike;
export type IdbQuery = IDBValidKey | IDBKeyRange;
export type IdbKey = IDBValidKey;
export declare const Idbs: {
	add: <T>(idb: Idb, key: IDBValidKey, value: T) => Promise<IDBValidKey>;
	put: <T_1>(idb: Idb<T_1>, key: IDBValidKey, value: T_1) => Promise<IDBValidKey>;
	get: <T_2>(idb: Idb<T_2>, query: IdbQuery, initial?: T_2 | ((() => T_2) | (() => Promise<T_2>))) => Promise<T_2>;
	list: <K extends IDBValidKey>(idb: Idb, query?: IDBValidKey | IDBKeyRange, count?: number) => Promise<K[]>;
	remove: <T_3>(idb: Idb, query: IdbQuery) => Promise<T_3>;
	update: <T_4>(idb: Idb<T_4>, key: IDBValidKey, mapper: (value: T_4) => T_4 | Promise<T_4>, initial?: T_4) => Promise<T_4>;
};
export type ImageLike = string | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ByteLike;
export declare const Images: {
	toHTMLImageElement: (src: ImageLike) => Promise<HTMLImageElement>;
	toHTMLCanvasElement: (src: ImageLike) => Promise<HTMLCanvasElement>;
	loadHTMLImageElement: (src: string) => Promise<HTMLImageElement>;
	toSrcString: (imageLike: ImageLike) => Promise<string>;
	from: (src: ImageLike) => Promise<{
		update: (updater: (img: {
			width: number;
			height: number;
			toDataURL: () => string;
			toBlob: () => Promise<unknown>;
		}) => {
			width: number;
			height: number;
			toDataURL: () => string;
			toBlob: () => Promise<unknown>;
		}) => any;
		toDataURL: () => string;
		toBlob: () => Promise<unknown>;
		get: <T>(getter: (img: {
			width: number;
			height: number;
			toDataURL: () => string;
			toBlob: () => Promise<unknown>;
		}) => T) => T;
		toHtmlImageElement: () => Promise<HTMLImageElement>;
		mapPixels: <T_1>(mapper: (pixel: number[]) => T_1) => T_1[];
	}>;
	toBlob: (src: ImageLike, type?: string, quality?: number) => Promise<Blob>;
};
export type InputListenOptions = Partial<{
	ratePerSecond: number;
	parent: HTMLElement;
	debug: boolean;
	autoUp: boolean;
	propagate: boolean;
	passive: boolean;
	dropMultiple: boolean;
	animateState: AnimateState;
	keyOptions: Partial<{
		[k in string]: {
			preventDefault: boolean;
		};
	}>;
}>;
export type KeyActions = {
	[k in string]: (key: string) => void;
};
export type MouseActionEvent = MouseEvent | WheelEvent;
export type PointerEventType = "click" | "auxclick" | "contextmenu" | "pointerdown" | "pointerenter" | "pointerleave" | "pointermove" | "pointerout" | "pointerover" | "wheel" | "pointerup";
export type MouseActions = {
	[k in PointerEventType]: (event: MouseActionEvent) => void;
};
export declare const Inputs: {
	listenToKey: (keyAction: KeyActions, options?: Partial<{
		ratePerSecond: number;
		parent: HTMLElement;
		debug: boolean;
		autoUp: boolean;
		propagate: boolean;
		passive: boolean;
		dropMultiple: boolean;
		animateState: AnimateState;
		keyOptions: Partial<{
			[x: string]: {
				preventDefault: boolean;
			};
		}>;
	}>) => AnimateState;
	listenToMouse: (mouseActions: Partial<MouseActions>, options?: Partial<{
		ratePerSecond: number;
		parent: HTMLElement;
		debug: boolean;
		autoUp: boolean;
		propagate: boolean;
		passive: boolean;
		dropMultiple: boolean;
		animateState: AnimateState;
		keyOptions: Partial<{
			[x: string]: {
				preventDefault: boolean;
			};
		}>;
	}>) => AnimateState;
};
export declare const Nlps: {
	levenshteinDistance: (word1: string | string[], word2: string | string[]) => [
		number,
		number
	];
	valueOfClosestMatch: <K extends string, V>(from: string, possibles: Record<K, V>, options?: Partial<{
		minConfidence: number;
	}>) => [
		V,
		number
	];
	summarizeText: (text: string) => Promise<string>;
};
export type SerializableNoiseState = {
	seed: number;
	distance: number;
};
/**
 * @returns 'random' 32bit unsigned
 */
export declare function noise(seed: number): number;
/**
 * creates a hash number using noise function
 * @param data
 * @returns
 */
export declare function noiseHash(data: number[]): number;
/**
 * @returns number between 0 and 1
 */
export declare function noiseUnit(seed: number): number;
/**
 * @param position will be converted to 32bit unsigned
 * @returns 'random' boolean
 */
export declare function noiseBoolean(position: number): boolean;
export declare function noiseStream(seed?: number): () => number;
declare function squirrel3(position: number): number;
export declare const Noises: {
	seed: (seed: any) => void;
	perlin2: (x: number, y: number) => number;
	perlin3: (x: any, y: any, z: any) => number;
	simplex2: (x: number, y: number) => number;
	simplex3: (x: number, y: number, z: number) => number;
	squirrel3: typeof squirrel3;
	noise: typeof noise;
	noiseHash: typeof noiseHash;
	noiseUnit: typeof noiseUnit;
	noiseBoolean: typeof noiseBoolean;
	noiseStream: typeof noiseStream;
	noiseRange: (seed?: number) => (max?: number, min?: number) => number;
	serializableNoiseStream: (state: Partial<SerializableNoiseState>) => () => number;
};
declare function escapeRegExp(str: string): string;
export type SseConsumer<T> = (value: T | undefined, done: boolean) => Boolish | Promise<Boolish>;
export type ComplexStopWord = {
	pre: string;
	mid: string;
	post: string;
	name: string;
};
export declare const Parsers: {
	createSseParser: <T>({ consumer, reader, onDone, onError, dataParser, signal, }: {
		signal?: AbortSignal | undefined;
		onDone?: (() => void) | undefined;
		onError?: ((err: unknown) => void) | undefined;
		reader: ReadableStreamDefaultReader<string>;
		dataParser?: ((data: string) => T | undefined) | undefined;
		consumer: SseConsumer<T>;
	}) => Promise<void>;
	createStreamParser: ({ onConsume, stopWords, }: {
		stopWords: ComplexStopWord[];
		onConsume?: ((text: string, stopWord: ComplexStopWord) => void) | undefined;
	}) => {
		reader: ReadableStreamDefaultReader<string>;
		write: (text: string) => void;
		close: () => void;
	};
	detectStop: (text: string | undefined, stopArrayOrString?: string | string[]) => [
		string | undefined,
		boolean
	];
	detectSimpleStop: (text: string | undefined, stops: string[]) => [
		string | undefined,
		boolean,
		number
	];
	detectStopAfter: (text: string | undefined, stopArrayOrString?: string | string[]) => [
		string | undefined,
		boolean
	];
	escapeRegExp: typeof escapeRegExp;
};
export declare const createEngine: (options?: EngineOptions) => Engine;
export type Vertices = PointObject2[];
export declare const Physics: {
	removeBody: (world: import("matter-js").World, label: string) => void;
	getBodyType: (world: import("matter-js").World, type: BodyType, id: string, options?: Partial<{
		type: BodyType;
		x: number;
		y: number;
		width: number;
		height: number;
		chamfer: number;
		slope: number;
		radius: number;
		sides: number;
		vertexSets: Vertices[];
		label: string;
		frictionAir: number;
		isStatic: boolean;
		mass: number;
		density: number;
		rotation: number;
		position: Point2;
		render: import("matter-js").IBodyRenderOptions;
	}> & Partial<{
		addToWorld: boolean;
	}>) => import("matter-js").Body;
	getCompoundBody: (world: import("matter-js").World, id: string, parts: import("matter-js").Body[], options?: Partial<{
		type: BodyType;
		x: number;
		y: number;
		width: number;
		height: number;
		chamfer: number;
		slope: number;
		radius: number;
		sides: number;
		vertexSets: Vertices[];
		label: string;
		frictionAir: number;
		isStatic: boolean;
		mass: number;
		density: number;
		rotation: number;
		position: Point2;
		render: import("matter-js").IBodyRenderOptions;
	}>) => import("matter-js").Body;
	updateBody: (body: import("matter-js").Body, options: Partial<{
		type: BodyType;
		x: number;
		y: number;
		width: number;
		height: number;
		chamfer: number;
		slope: number;
		radius: number;
		sides: number;
		vertexSets: Vertices[];
		label: string;
		frictionAir: number;
		isStatic: boolean;
		mass: number;
		density: number;
		rotation: number;
		position: Point2;
		render: import("matter-js").IBodyRenderOptions;
	}>) => void;
	update: (engine: import("matter-js").Engine, deltaMs: number, lastDeltaMs?: number) => void;
	updateRender: (render: import("matter-js").Render) => void;
	createRender: (engine: import("matter-js").Engine, options?: Partial<{
		canvas: HTMLCanvasElement;
	} & import("matter-js").IRenderDefinition>) => import("matter-js").Render;
	helloWorld: ({ engine, canvas, run, }?: Partial<{
		canvas: HTMLCanvasElement;
		engine: import("matter-js").Engine;
		run: boolean;
	}>) => {
		engine: import("matter-js").Engine;
		canvas: HTMLCanvasElement;
		render: import("matter-js").Render;
	} | {
		engine: import("matter-js").Engine;
		canvas: HTMLCanvasElement;
		render?: undefined;
	};
	applyForce: (world: import("matter-js").World, id: string, force: Point2, position?: Point2) => void;
	createEngine: (options?: Partial<{
		enableSleeping: boolean;
		gravity: Partial<{
			scale: number;
			x: number;
			y: number;
		}>;
	}>) => import("matter-js").Engine;
	allBodies: (world: import("matter-js").World) => import("matter-js").Body[];
	findBody: (world: import("matter-js").World, labelOrPredicate: string | ((body: import("matter-js").Body) => boolean)) => import("matter-js").Body;
	findBodies: (world: import("matter-js").World, labelOrPredicate: string | ((body: import("matter-js").Body) => boolean)) => import("matter-js").Body[];
	queryCollisions: (world: import("matter-js").World, needle: string | Point2, hayStack: string[]) => import("matter-js").Body[] | import("matter-js").ICollision[];
	runRunner: (engine: import("matter-js").Engine) => import("matter-js").Runner;
	runRender: (render: import("matter-js").Render) => void;
	setPosition: (world: import("matter-js").World, label: string, position?: Point2) => void;
	getPosition: (world: import("matter-js").World, label: string) => PointObject2;
	getRotation: (world: import("matter-js").World, label: string) => number;
	setRotation: (world: import("matter-js").World, id: string, rotation: number) => void;
	getInertia: (world: import("matter-js").World, label: string) => number;
	setInertia: (world: import("matter-js").World, label: string, inertia?: number) => void;
	getVelocity: (world: import("matter-js").World, label: string) => PointObject2;
	setVelocity: (world: import("matter-js").World, label: string, velocity?: Point2) => void;
	getMass: (world: import("matter-js").World, label: string) => number;
};
export type BodyType = "circle" | "rectangle" | "polygon" | "trapezoid" | "vertex";
export type BodySpec = Partial<{
	type: BodyType;
	x: number;
	y: number;
	width: number;
	height: number;
	chamfer: number;
	slope: number;
	radius: number;
	sides: number;
	vertexSets: Vertices[];
	label: string;
	frictionAir: number;
	isStatic: boolean;
	mass: number;
	density: number;
	rotation: number;
	position: Point2;
	render: IBodyRenderOptions;
}>;
export type EngineOptions = Partial<{
	enableSleeping: boolean;
	gravity: Partial<{
		scale: number;
		x: number;
		y: number;
	}>;
}>;
export type PhysicsBody = Body;
export type PhysicsEngine = ReturnType<typeof createEngine>;
export type PhysicsWorld = World;
export declare const update: (engine: Engine, deltaMs: number, lastDeltaMs?: number) => void;
export declare const ArrayToGrid: <T extends string | object | number>({ arr, columns, mapper, }: {
	mapper?: (value: T) => ReactNode;
	arr: T[];
	columns?: number;
}) => import("react/jsx-runtime").JSX.Element;
export type ReactCssProperties = React.CSSProperties;
export declare const BasicWindow: ({ title, children, left, top, resizeable, style, }: {
	style?: ReactCssProperties;
	left?: string;
	top?: string;
	title?: string;
	children?: ReactNode;
	resizeable?: boolean;
}) => import("react/jsx-runtime").JSX.Element;
export declare const Center: ({ children, className, style, }: {
	className?: string;
	children?: ReactNode;
	style?: React.CSSProperties;
}) => import("react/jsx-runtime").JSX.Element;
export declare const Click: ({ children, to, open, openId, tooltip, tooltipDelayMills, action, contextMenu, }: {
	action?: (e: React.MouseEvent) => void;
	open?: ReactNode;
	openId?: string;
	tooltipDelayMills?: number;
	tooltip?: ReactChild;
	contextMenu?: ReactChild;
	to?: string;
	children?: ReactNode;
}) => import("react/jsx-runtime").JSX.Element;
export type WindowActions = {
	setOffsetX: React.Dispatch<React.SetStateAction<number>>;
	setOffsetY: React.Dispatch<React.SetStateAction<number>>;
	setMoveEnabled: React.Dispatch<React.SetStateAction<boolean>>;
	setPointer: React.Dispatch<React.SetStateAction<"none" | "auto">>;
};
export type WinCtx = {
	actions: WindowActions;
};
export type FrameControl = (winCtx: WinCtx) => void;
/** @see https://raw.githubusercontent.com/jossef/material-design-icons-iconfont/master/dist/fonts/MaterialIcons-Regular.json */
export type MaterialIconCodes = {
	"123": "EB8D";
	"360": "E577";
	"1x_mobiledata": "EFCD";
	"1k_plus": "E95D";
	"1k": "E95C";
	"19mp": "E95B";
	"18mp": "E95A";
	"17mp": "E959";
	"16mp": "E958";
	"15mp": "E957";
	"14mp": "E956";
	"13mp": "E955";
	"12mp": "E954";
	"11mp": "E953";
	"10mp": "E952";
	"10k": "E951";
	"2k_plus": "E964";
	"24mp": "E962";
	"23mp": "E961";
	"22mp": "E960";
	"21mp": "E95F";
	"20mp": "E95E";
	"2mp": "E965";
	"2k": "E963";
	"3p": "EFD1";
	"3mp": "E968";
	"3k_plus": "E967";
	"3k": "E966";
	"3g_mobiledata": "EFD0";
	"3d_rotation": "E84D";
	"30fps_select": "EFCF";
	"30fps": "EFCE";
	"4mp": "E96A";
	"4k_plus": "E969";
	"4k": "E072";
	"4g_plus_mobiledata": "EFD3";
	"4g_mobiledata": "EFD2";
	"5mp": "E96D";
	"5k_plus": "E96C";
	"5k": "E96B";
	"5g": "EF38";
	"6mp": "E970";
	"6k_plus": "E96F";
	"6k": "E96E";
	"6_ft_apart": "F21E";
	"60fps_select": "EFD5";
	"60fps": "EFD4";
	"7k_plus": "E972";
	"7mp": "E973";
	"7k": "E971";
	"8k_plus": "E975";
	"8mp": "E976";
	"8k": "E974";
	"9k_plus": "E978";
	"9mp": "E979";
	"9k": "E977";
	av_timer: "E01B";
	autorenew: "E863";
	autofps_select: "EFDC";
	auto_stories: "E666";
	auto_graph: "E4FB";
	auto_fix_off: "E665";
	auto_fix_normal: "E664";
	auto_fix_high: "E663";
	auto_delete: "EA4C";
	auto_awesome_motion: "E661";
	auto_awesome_mosaic: "E660";
	auto_awesome: "E65F";
	audiotrack: "E3A1";
	audio_file: "EB82";
	attribution: "EFDB";
	attractions: "EA52";
	attachment: "E2BC";
	attach_money: "E227";
	attach_file: "E226";
	attach_email: "EA5E";
	atm: "E573";
	assured_workload: "EB6F";
	assistant_photo: "E3A0";
	assistant_navigation: "E989";
	assistant_direction: "E988";
	assistant: "E39F";
	assignment_turned_in: "E862";
	assignment_returned: "E861";
	assignment_return: "E860";
	assignment_late: "E85F";
	assignment_ind: "E85E";
	assignment: "E85D";
	assessment: "E85C";
	aspect_ratio: "E85B";
	article: "EF42";
	art_track: "E060";
	arrow_upward: "E5D8";
	arrow_right_alt: "E941";
	arrow_right: "E5DF";
	arrow_left: "E5DE";
	arrow_forward_ios: "E5E1";
	arrow_forward: "E5C8";
	arrow_drop_up: "E5C7";
	arrow_drop_down_circle: "E5C6";
	arrow_drop_down: "E5C5";
	arrow_downward: "E5DB";
	arrow_circle_up: "F182";
	arrow_circle_right: "EAAA";
	arrow_circle_left: "EAA7";
	arrow_circle_down: "F181";
	arrow_back_ios_new: "E2EA";
	arrow_back_ios: "E5E0";
	arrow_back: "E5C4";
	area_chart: "E770";
	archive: "E149";
	architecture: "EA3B";
	apps_outage: "E7CC";
	apps: "E5C3";
	approval: "E982";
	apple: "EA80";
	app_shortcut: "EAE4";
	app_settings_alt: "EF41";
	app_registration: "EF40";
	app_blocking: "EF3F";
	api: "F1B7";
	apartment: "EA40";
	aod: "EFDA";
	announcement: "E85A";
	animation: "E71C";
	android: "E859";
	anchor: "F1CD";
	analytics: "EF3E";
	amp_stories: "EA13";
	alternate_email: "E0E6";
	alt_route: "F184";
	all_out: "E90B";
	all_inclusive: "EB3D";
	all_inbox: "E97F";
	align_vertical_top: "E00C";
	align_vertical_center: "E011";
	align_vertical_bottom: "E015";
	align_horizontal_right: "E010";
	align_horizontal_left: "E00D";
	align_horizontal_center: "E00F";
	album: "E019";
	alarm_on: "E858";
	alarm_off: "E857";
	alarm_add: "E856";
	alarm: "E855";
	airport_shuttle: "EB3C";
	airplay: "E055";
	airplanemode_on: "E195";
	airplanemode_off: "E194";
	airplanemode_inactive: "E194";
	airplanemode_active: "E195";
	airplane_ticket: "EFD9";
	airlines: "E7CA";
	airline_stops: "E7D0";
	airline_seat_recline_normal: "E637";
	airline_seat_recline_extra: "E636";
	airline_seat_legroom_reduced: "E635";
	airline_seat_legroom_normal: "E634";
	airline_seat_legroom_extra: "E633";
	airline_seat_individual_suite: "E632";
	airline_seat_flat_angled: "E631";
	airline_seat_flat: "E630";
	air: "EFD8";
	agriculture: "EA79";
	ads_click: "E762";
	adobe: "EA96";
	admin_panel_settings: "EF3D";
	adjust: "E39E";
	adf_scanner: "EADA";
	addchart: "EF3C";
	add_to_queue: "E05C";
	add_to_photos: "E39D";
	add_to_home_screen: "E1FE";
	add_to_drive: "E65C";
	add_task: "F23A";
	add_shopping_cart: "E854";
	add_road: "EF3B";
	add_reaction: "E1D3";
	add_photo_alternate: "E43E";
	add_moderator: "E97D";
	add_location_alt: "EF3A";
	add_location: "E567";
	add_link: "E178";
	add_ic_call: "E97C";
	add_comment: "E266";
	add_circle_outline: "E148";
	add_circle: "E147";
	add_chart: "E97B";
	add_card: "EB86";
	add_call: "E0E8";
	add_business: "E729";
	add_box: "E146";
	add_alert: "E003";
	add_alarm: "E193";
	add_a_photo: "E439";
	add: "E145";
	adb: "E60E";
	ad_units: "EF39";
	account_tree: "E97A";
	account_circle: "E853";
	account_box: "E851";
	account_balance_wallet: "E850";
	account_balance: "E84F";
	accessible_forward: "E934";
	accessible: "E914";
	accessibility_new: "E92C";
	accessibility: "E84E";
	access_time_filled: "EFD6";
	access_time: "E192";
	access_alarms: "E191";
	access_alarm: "E190";
	ac_unit: "EB3B";
	abc: "EB94";
	business_center: "EB3F";
	business: "E0AF";
	bus_alert: "E98F";
	burst_mode: "E43C";
	bungalow: "E591";
	build_circle: "EF48";
	build: "E869";
	bug_report: "E868";
	bubble_chart: "E6DD";
	brush: "E3AE";
	brunch_dining: "EA73";
	browser_updated: "E7CF";
	browser_not_supported: "EF47";
	browse_gallery: "EBD1";
	broken_image: "E3AD";
	brightness_medium: "E1AE";
	brightness_low: "E1AD";
	brightness_high: "E1AC";
	brightness_auto: "E1AB";
	brightness_7: "E3AC";
	brightness_6: "E3AB";
	brightness_5: "E3AA";
	brightness_4: "E3A9";
	brightness_3: "E3A8";
	brightness_2: "E3A7";
	brightness_1: "E3A6";
	breakfast_dining: "EA54";
	branding_watermark: "E06B";
	boy: "EB67";
	border_vertical: "E233";
	border_top: "E232";
	border_style: "E231";
	border_right: "E230";
	border_outer: "E22F";
	border_left: "E22E";
	border_inner: "E22D";
	border_horizontal: "E22C";
	border_color: "E22B";
	border_clear: "E22A";
	border_bottom: "E229";
	border_all: "E228";
	bookmarks: "E98B";
	bookmark_remove: "E59A";
	bookmark_outline: "E867";
	bookmark_border: "E867";
	bookmark_added: "E599";
	bookmark_add: "E598";
	bookmark: "E866";
	book_online: "F217";
	book: "E865";
	bolt: "EA0B";
	blur_on: "E3A5";
	blur_off: "E3A4";
	blur_linear: "E3A3";
	blur_circular: "E3A2";
	bluetooth_searching: "E1AA";
	bluetooth_drive: "EFE5";
	bluetooth_disabled: "E1A9";
	bluetooth_connected: "E1A8";
	bluetooth_audio: "E60F";
	bluetooth: "E1A7";
	bloodtype: "EFE4";
	block_flipped: "EF46";
	block: "E14B";
	blender: "EFE3";
	biotech: "EA3A";
	bike_scooter: "EF45";
	bento: "F1F4";
	beenhere: "E52D";
	bedtime_off: "EB76";
	bedtime: "EF44";
	bedroom_parent: "EFE2";
	bedroom_child: "EFE1";
	bedroom_baby: "EFE0";
	bed: "EFDF";
	beach_access: "EB3E";
	battery_unknown: "E1A6";
	battery_std: "E1A5";
	battery_saver: "EFDE";
	battery_full: "E1A4";
	battery_charging_full: "E1A3";
	battery_alert: "E19C";
	bathtub: "EA41";
	bathroom: "EFDD";
	batch_prediction: "F0F5";
	bar_chart: "E26B";
	ballot: "E172";
	balcony: "E58F";
	balance: "EAF6";
	bakery_dining: "EA53";
	badge: "EA67";
	backup_table: "EF43";
	backup: "E864";
	backspace: "E14A";
	backpack: "F19C";
	back_hand: "E764";
	baby_changing_station: "F19B";
	currency_yuan: "EAF9";
	currency_yen: "EAFB";
	currency_rupee: "EAF7";
	currency_ruble: "EAEC";
	currency_pound: "EAF1";
	currency_lira: "EAEF";
	currency_franc: "EAFA";
	currency_exchange: "EB70";
	currency_bitcoin: "EBC5";
	css: "EB93";
	cruelty_free: "E799";
	crop_square: "E3C6";
	crop_rotate: "E437";
	crop_portrait: "E3C5";
	crop_original: "E3C4";
	crop_landscape: "E3C3";
	crop_free: "E3C2";
	crop_din: "E3C1";
	crop_7_5: "E3C0";
	crop_5_4: "E3BF";
	crop_3_2: "E3BD";
	crop_16_9: "E3BC";
	crop: "E3BE";
	crib: "E588";
	credit_score: "EFF1";
	credit_card_off: "E4F4";
	credit_card: "E870";
	create_new_folder: "E2CC";
	create: "E150";
	countertops: "F1F7";
	cottage: "E587";
	corporate_fare: "F1D0";
	coronavirus: "F221";
	copyright: "E90C";
	copy_all: "E2EC";
	cookie: "EAAC";
	control_point_duplicate: "E3BB";
	control_point: "E3BA";
	control_camera: "E074";
	contrast: "EB37";
	content_paste_search: "EA9B";
	content_paste_off: "E4F8";
	content_paste_go: "EA8E";
	content_paste: "E14F";
	content_cut: "E14E";
	content_copy: "E14D";
	contacts: "E0BA";
	contactless: "EA71";
	contact_support: "E94C";
	contact_phone: "E0CF";
	contact_page: "F22E";
	contact_mail: "E0D0";
	construction: "EA3C";
	connecting_airports: "E7C9";
	connected_tv: "E998";
	connect_without_contact: "F223";
	confirmation_number: "E638";
	confirmation_num: "E638";
	computer: "E30A";
	compress: "E94D";
	compost: "E761";
	compass_calibration: "E57C";
	compare_arrows: "E915";
	compare: "E3B9";
	commute: "E940";
	commit: "EAF5";
	comments_disabled: "E7A2";
	comment_bank: "EA4E";
	comment: "E0B9";
	colorize: "E3B8";
	color_lens: "E3B7";
	collections_bookmark: "E431";
	collections: "E3B6";
	coffee_maker: "EFF0";
	coffee: "EFEF";
	code_off: "E4F3";
	code: "E86F";
	co_present: "EAF0";
	co2: "E7B0";
	cloudy_snowing: "E810";
	cloud_upload: "E2C3";
	cloud_sync: "EB5A";
	cloud_queue: "E2C2";
	cloud_off: "E2C1";
	cloud_download: "E2C0";
	cloud_done: "E2BF";
	cloud_circle: "E2BE";
	cloud: "E2BD";
	closed_caption_off: "E996";
	closed_caption_disabled: "F1DC";
	closed_caption: "E01C";
	close_fullscreen: "F1CF";
	close: "E5CD";
	clear_all: "E0B8";
	clear: "E14C";
	cleaning_services: "F0FF";
	clean_hands: "F21F";
	class: "E86E";
	circle_notifications: "E994";
	circle: "EF4A";
	church: "EAAE";
	chrome_reader_mode: "E86D";
	child_friendly: "EB42";
	child_care: "EB41";
	chevron_right: "E5CC";
	chevron_left: "E5CB";
	checkroom: "F19E";
	checklist_rtl: "E6B3";
	checklist: "E6B1";
	check_circle_outline: "E92D";
	check_circle: "E86C";
	check_box_outline_blank: "E835";
	check_box: "E834";
	check: "E5CA";
	chat_bubble_outline: "E0CB";
	chat_bubble: "E0CA";
	chat: "E0B7";
	charging_station: "F19D";
	change_history: "E86B";
	change_circle: "E2E7";
	chalet: "E585";
	chair_alt: "EFEE";
	chair: "EFED";
	center_focus_weak: "E3B5";
	center_focus_strong: "E3B4";
	cell_wifi: "E0EC";
	cell_tower: "EBBA";
	celebration: "EA65";
	category: "E574";
	catching_pokemon: "E508";
	castle: "EAB1";
	cast_for_education: "EFEC";
	cast_connected: "E308";
	cast: "E307";
	casino: "EB40";
	cases: "E992";
	carpenter: "F1F8";
	card_travel: "E8F8";
	card_membership: "E8F7";
	card_giftcard: "E8F6";
	car_repair: "EA56";
	car_rental: "EA55";
	candlestick_chart: "EAD4";
	cancel_schedule_send: "EA39";
	cancel_presentation: "E0E9";
	cancel: "E5C9";
	campaign: "EF49";
	cameraswitch: "EFEB";
	camera_roll: "E3B3";
	camera_rear: "E3B2";
	camera_outdoor: "EFEA";
	camera_indoor: "EFE9";
	camera_front: "E3B1";
	camera_enhance: "E8FC";
	camera_alt: "E3B0";
	camera: "E3AF";
	call_to_action: "E06C";
	call_split: "E0B6";
	call_received: "E0B5";
	call_missed_outgoing: "E0E4";
	call_missed: "E0B4";
	call_merge: "E0B3";
	call_made: "E0B2";
	call_end: "E0B1";
	call: "E0B0";
	calendar_view_week: "EFE8";
	calendar_view_month: "EFE7";
	calendar_view_day: "E936";
	calendar_today: "E935";
	calendar_month: "EBCC";
	calculate: "EA5F";
	cake: "E7E9";
	cached: "E86A";
	cable: "EFE6";
	cabin: "E589";
	dynamic_form: "F1BF";
	dynamic_feed: "EA14";
	dvr: "E1B2";
	duo: "E9A5";
	dry_cleaning: "EA58";
	dry: "F1B3";
	drive_folder_upload: "E9A3";
	drive_file_rename_outline: "E9A2";
	drive_file_move_rtl: "E76D";
	drive_file_move_outline: "E9A1";
	drive_file_move: "E675";
	drive_eta: "E613";
	draw: "E746";
	drag_indicator: "E945";
	drag_handle: "E25D";
	drafts: "E151";
	downloading: "F001";
	download_for_offline: "F000";
	download_done: "F091";
	download: "F090";
	downhill_skiing: "E509";
	double_arrow: "EA50";
	doorbell: "EFFF";
	door_sliding: "EFFE";
	door_front: "EFFD";
	door_back: "EFFC";
	donut_small: "E918";
	donut_large: "E917";
	done_outline: "E92F";
	done_all: "E877";
	done: "E876";
	domain_verification: "EF4C";
	domain_disabled: "E0EF";
	domain_add: "EB62";
	domain: "E7EE";
	document_scanner: "E5FA";
	dock: "E30E";
	do_not_touch: "F1B0";
	do_not_step: "F19F";
	do_not_disturb_on_total_silence: "EFFB";
	do_not_disturb_on: "E644";
	do_not_disturb_off: "E643";
	do_not_disturb_alt: "E611";
	do_not_disturb: "E612";
	do_disturb_on: "F08F";
	do_disturb_off: "F08E";
	do_disturb_alt: "F08D";
	do_disturb: "F08C";
	dns: "E875";
	dnd_forwardslash: "E611";
	display_settings: "EB97";
	discount: "EBC9";
	discord: "EA6C";
	disc_full: "E610";
	disabled_visible: "E76E";
	disabled_by_default: "F230";
	dirty_lens: "EF4B";
	directions_walk: "E536";
	directions_transit_filled: "EFFA";
	directions_transit: "E535";
	directions_train: "E534";
	directions_subway_filled: "EFF9";
	directions_subway: "E533";
	directions_run: "E566";
	directions_railway_filled: "EFF8";
	directions_railway: "E534";
	directions_off: "F10F";
	directions_ferry: "E532";
	directions_car_filled: "EFF7";
	directions_car: "E531";
	directions_bus_filled: "EFF6";
	directions_bus: "E530";
	directions_boat_filled: "EFF5";
	directions_boat: "E532";
	directions_bike: "E52F";
	directions: "E52E";
	dinner_dining: "EA57";
	dining: "EFF4";
	difference: "EB7D";
	diamond: "EAD5";
	dialpad: "E0BC";
	dialer_sip: "E0BB";
	devices_other: "E337";
	devices: "E1B1";
	device_unknown: "E339";
	device_thermostat: "E1FF";
	device_hub: "E335";
	developer_mode: "E1B0";
	developer_board_off: "E4FF";
	developer_board: "E30D";
	details: "E3C8";
	desktop_windows: "E30C";
	desktop_mac: "E30B";
	desktop_access_disabled: "E99D";
	design_services: "F10A";
	deselect: "EBB6";
	description: "E873";
	departure_board: "E576";
	density_small: "EBA8";
	density_medium: "EB9E";
	density_large: "EBA9";
	delivery_dining: "EA72";
	delete_sweep: "E16C";
	delete_outline: "E92E";
	delete_forever: "E92B";
	delete: "E872";
	dehaze: "E3C7";
	deck: "EA42";
	deblur: "EB77";
	date_range: "E916";
	data_usage: "E1AF";
	data_thresholding: "EB9F";
	data_saver_on: "EFF3";
	data_saver_off: "EFF2";
	data_object: "EAD3";
	data_exploration: "E76F";
	data_array: "EAD1";
	dashboard_customize: "E99B";
	dashboard: "E871";
	dark_mode: "E51C";
	dangerous: "E99A";
	extension_off: "E4F5";
	extension: "E87B";
	exposure_zero: "E3CF";
	exposure_plus_2: "E3CE";
	exposure_plus_1: "E3CD";
	exposure_neg_2: "E3CC";
	exposure_neg_1: "E3CB";
	exposure_minus_2: "E3CC";
	exposure_minus_1: "E3CB";
	exposure: "E3CA";
	explore_off: "E9A8";
	explore: "E87A";
	explicit: "E01E";
	expand_more: "E5CF";
	expand_less: "E5CE";
	expand_circle_down: "E7CD";
	expand: "E94F";
	exit_to_app: "E879";
	event_seat: "E903";
	event_repeat: "EB7B";
	event_note: "E616";
	event_busy: "E615";
	event_available: "E614";
	event: "E878";
	ev_station: "E56D";
	euro_symbol: "E926";
	euro: "EA15";
	escalator_warning: "F1AC";
	escalator: "F1A1";
	error_outline: "E001";
	error: "E000";
	equalizer: "E01D";
	enhanced_encryption: "E63F";
	enhance_photo_translate: "E8FC";
	engineering: "EA3D";
	emoji_transportation: "EA1F";
	emoji_symbols: "EA1E";
	emoji_people: "EA1D";
	emoji_objects: "EA24";
	emoji_nature: "EA1C";
	emoji_food_beverage: "EA1B";
	emoji_flags: "EA1A";
	emoji_events: "EA23";
	emoji_emotions: "EA22";
	emergency: "E1EB";
	email: "E0BE";
	elevator: "F1A0";
	electrical_services: "F102";
	electric_scooter: "EB1F";
	electric_rickshaw: "EB1E";
	electric_moped: "EB1D";
	electric_car: "EB1C";
	electric_bike: "EB1B";
	elderly_woman: "EB69";
	elderly: "F21A";
	eject: "E8FB";
	egg_alt: "EAC8";
	egg: "EACC";
	edit_road: "EF4D";
	edit_off: "E950";
	edit_notifications: "E525";
	edit_note: "E745";
	edit_location_alt: "E1C5";
	edit_location: "E568";
	edit_calendar: "E742";
	edit_attributes: "E578";
	edit: "E3C9";
	edgesensor_low: "F006";
	edgesensor_high: "F005";
	eco: "EA35";
	east: "F1DF";
	earbuds_battery: "F004";
	earbuds: "F003";
	e_mobiledata: "F002";
	functions: "E24A";
	fullscreen_exit: "E5D1";
	fullscreen: "E5D0";
	front_hand: "E769";
	free_cancellation: "E748";
	free_breakfast: "EB44";
	foundation: "F200";
	forward_to_inbox: "F187";
	forward_5: "E058";
	forward_30: "E057";
	forward_10: "E056";
	forward: "E154";
	forum: "E0BF";
	fort: "EAAD";
	format_underlined: "E249";
	format_underline: "E249";
	format_textdirection_r_to_l: "E248";
	format_textdirection_l_to_r: "E247";
	format_strikethrough: "E246";
	format_size: "E245";
	format_shapes: "E25E";
	format_quote: "E244";
	format_paint: "E243";
	format_overline: "EB65";
	format_list_numbered_rtl: "E267";
	format_list_numbered: "E242";
	format_list_bulleted: "E241";
	format_line_spacing: "E240";
	format_italic: "E23F";
	format_indent_increase: "E23E";
	format_indent_decrease: "E23D";
	format_color_text: "E23C";
	format_color_reset: "E23B";
	format_color_fill: "E23A";
	format_clear: "E239";
	format_bold: "E238";
	format_align_right: "E237";
	format_align_left: "E236";
	format_align_justify: "E235";
	format_align_center: "E234";
	fork_right: "EBAC";
	fork_left: "EBA0";
	forest: "EA99";
	food_bank: "F1F2";
	font_download_off: "E4F9";
	font_download: "E167";
	follow_the_signs: "F222";
	folder_zip: "EB2C";
	folder_special: "E617";
	folder_shared: "E2C9";
	folder_open: "E2C8";
	folder_off: "EB83";
	folder_delete: "EB34";
	folder_copy: "EBBD";
	folder: "E2C7";
	foggy: "E818";
	fmd_good: "F00F";
	fmd_bad: "F00E";
	flutter_dash: "E00B";
	flourescent: "F00D";
	flip_to_front: "E883";
	flip_to_back: "E882";
	flip_camera_ios: "EA38";
	flip_camera_android: "EA37";
	flip: "E3E8";
	flight_takeoff: "E905";
	flight_land: "E904";
	flight_class: "E7CB";
	flight: "E539";
	flatware: "F00C";
	flashlight_on: "F00B";
	flashlight_off: "F00A";
	flash_on: "E3E7";
	flash_off: "E3E6";
	flash_auto: "E3E5";
	flare: "E3E4";
	flaky: "EF50";
	flag_circle: "EAF8";
	flag: "E153";
	fitness_center: "EB43";
	fitbit: "E82B";
	fit_screen: "EA10";
	first_page: "E5DC";
	fireplace: "EA43";
	fire_hydrant: "F1A3";
	fire_extinguisher: "F1D8";
	fingerprint: "E90D";
	find_replace: "E881";
	find_in_page: "E880";
	filter_vintage: "E3E3";
	filter_tilt_shift: "E3E2";
	filter_none: "E3E0";
	filter_list_off: "EB57";
	filter_list_alt: "E94E";
	filter_list: "E152";
	filter_hdr: "E3DF";
	filter_frames: "E3DE";
	filter_drama: "E3DD";
	filter_center_focus: "E3DC";
	filter_b_and_w: "E3DB";
	filter_alt_off: "EB32";
	filter_alt: "EF4F";
	filter_9_plus: "E3DA";
	filter_9: "E3D9";
	filter_8: "E3D8";
	filter_7: "E3D7";
	filter_6: "E3D6";
	filter_5: "E3D5";
	filter_4: "E3D4";
	filter_3: "E3D2";
	filter_2: "E3D1";
	filter_1: "E3D0";
	filter: "E3D3";
	file_upload: "E2C6";
	file_present: "EA0E";
	file_open: "EAF3";
	file_download_off: "E4FE";
	file_download_done: "E9AA";
	file_download: "E2C4";
	file_copy: "E173";
	fiber_smart_record: "E062";
	fiber_pin: "E06A";
	fiber_new: "E05E";
	fiber_manual_record: "E061";
	fiber_dvr: "E05D";
	festival: "EA68";
	fence: "F1F6";
	female: "E590";
	feedback: "E87F";
	feed: "F009";
	featured_video: "E06E";
	featured_play_list: "E06D";
	fax: "EAD8";
	favorite_outline: "E87E";
	favorite_border: "E87E";
	favorite: "E87D";
	fastfood: "E57A";
	fast_rewind: "E020";
	fast_forward: "E01F";
	family_restroom: "F1A2";
	factory: "EBBC";
	fact_check: "F0C5";
	facebook: "F234";
	face_retouching_off: "F007";
	face_retouching_natural: "EF4E";
	face: "E87C";
	groups: "F233";
	group_work: "E886";
	group_remove: "E7AD";
	group_off: "E747";
	group_add: "E7F0";
	group: "E7EF";
	grid_view: "E9B0";
	grid_on: "E3EC";
	grid_off: "E3EB";
	grid_goldenratio: "F017";
	grid_4x4: "F016";
	grid_3x3: "F015";
	grass: "F205";
	graphic_eq: "E1B8";
	grain: "E3EA";
	grading: "EA4F";
	gradient: "E3E9";
	grade: "E885";
	gps_off: "E1B5";
	gps_not_fixed: "E1B4";
	gps_fixed: "E1B3";
	gpp_maybe: "F014";
	gpp_good: "F013";
	gpp_bad: "F012";
	golf_course: "EB45";
	goat: "EBFF";
	gite: "E58B";
	girl: "EB68";
	gif_box: "E7A3";
	gif: "E908";
	get_app: "E884";
	gesture: "E155";
	generating_tokens: "E749";
	gavel: "E90E";
	garage: "F011";
	games: "E021";
	gamepad: "E30F";
	g_translate: "E927";
	g_mobiledata: "F010";
	hvac: "F10E";
	hub: "E9F4";
	https: "E88D";
	http: "E902";
	html: "EB7E";
	how_to_vote: "E175";
	how_to_reg: "E174";
	houseboat: "E584";
	house_siding: "F202";
	house: "EA44";
	hourglass_top: "EA5B";
	hourglass_full: "E88C";
	hourglass_empty: "E88B";
	hourglass_disabled: "EF53";
	hourglass_bottom: "EA5C";
	hotel_class: "E743";
	hotel: "E53A";
	hot_tub: "EB46";
	horizontal_split: "E947";
	horizontal_rule: "F108";
	horizontal_distribute: "E014";
	home_work: "EA09";
	home_repair_service: "F100";
	home_mini: "F025";
	home_max: "F024";
	home_filled: "E9B2";
	home: "E88A";
	holiday_village: "E58A";
	hls_off: "EB8C";
	hls: "EB8A";
	hive: "EAA6";
	history_toggle_off: "F17D";
	history_edu: "EA3E";
	history: "E889";
	hiking: "E50A";
	highlight_remove: "E888";
	highlight_off: "E888";
	highlight_alt: "EF52";
	highlight: "E25F";
	high_quality: "E024";
	hide_source: "F023";
	hide_image: "F022";
	hexagon: "EB39";
	hevc: "F021";
	help_outline: "E8FD";
	help_center: "F1C0";
	help: "E887";
	height: "EA16";
	heart_broken: "EAC2";
	hearing_disabled: "F104";
	hearing: "E023";
	health_and_safety: "E1D5";
	healing: "E3F3";
	headset_off: "E33A";
	headset_mic: "E311";
	headset: "E310";
	headphones_battery: "F020";
	headphones: "F01F";
	hdr_weak: "E3F2";
	hdr_strong: "E3F1";
	hdr_plus: "F01E";
	hdr_on_select: "F01D";
	hdr_on: "E3EE";
	hdr_off_select: "F01C";
	hdr_off: "E3ED";
	hdr_enhanced_select: "EF51";
	hdr_auto_select: "F01B";
	hdr_auto: "F01A";
	hd: "E052";
	hardware: "EA59";
	handyman: "F10B";
	handshake: "EBCB";
	hail: "E9B1";
	h_plus_mobiledata: "F019";
	h_mobiledata: "F018";
	iso: "E3F6";
	iron: "E583";
	ios_share: "E6B8";
	invert_colors_on: "E891";
	invert_colors_off: "E0C4";
	invert_colors: "E891";
	inventory_2: "E1A1";
	inventory: "E179";
	interpreter_mode: "E83B";
	interests: "E7C8";
	integration_instructions: "EF54";
	install_mobile: "EB72";
	install_desktop: "EB71";
	insights: "F092";
	insert_photo: "E251";
	insert_page_break: "EACA";
	insert_link: "E250";
	insert_invitation: "E24F";
	insert_emoticon: "E24E";
	insert_drive_file: "E24D";
	insert_comment: "E24C";
	insert_chart_outlined: "E26A";
	insert_chart: "E24B";
	input: "E890";
	info_outline: "E88F";
	info: "E88E";
	indeterminate_check_box: "E909";
	incomplete_circle: "E79B";
	inbox: "E156";
	important_devices: "E912";
	import_export: "E0C3";
	import_contacts: "E0E0";
	imagesearch_roller: "E9B4";
	image_search: "E43F";
	image_not_supported: "F116";
	image_aspect_ratio: "E3F5";
	image: "E3F4";
	icecream: "EA69";
	ice_skating: "E50B";
	join_right: "EAEA";
	join_left: "EAF2";
	join_inner: "EAF4";
	join_full: "EAEB";
	javascript: "EB7C";
	kitesurfing: "E50D";
	kitchen: "EB47";
	king_bed: "EA45";
	keyboard_voice: "E31D";
	keyboard_tab: "E31C";
	keyboard_return: "E31B";
	keyboard_option_key: "EAE8";
	keyboard_option: "EADF";
	keyboard_hide: "E31A";
	keyboard_double_arrow_up: "EACF";
	keyboard_double_arrow_right: "EAC9";
	keyboard_double_arrow_left: "EAC3";
	keyboard_double_arrow_down: "EAD0";
	keyboard_control_key: "EAE6";
	keyboard_control: "E5D3";
	keyboard_command_key: "EAE7";
	keyboard_command: "EAE0";
	keyboard_capslock: "E318";
	keyboard_backspace: "E317";
	keyboard_arrow_up: "E316";
	keyboard_arrow_right: "E315";
	keyboard_arrow_left: "E314";
	keyboard_arrow_down: "E313";
	keyboard_alt: "F028";
	keyboard: "E312";
	key_off: "EB84";
	key: "E73C";
	kebab_dining: "E842";
	kayaking: "E50C";
	lunch_dining: "EA61";
	luggage: "F235";
	lte_plus_mobiledata: "F02D";
	lte_mobiledata: "F02C";
	loyalty: "E89A";
	low_priority: "E16D";
	loupe: "E402";
	loop: "E028";
	looks_two: "E401";
	looks_one: "E400";
	looks_6: "E3FF";
	looks_5: "E3FE";
	looks_4: "E3FD";
	looks_3: "E3FB";
	looks: "E3FC";
	logout: "E9BA";
	logo_dev: "EAD6";
	login: "EA77";
	lock_reset: "EADE";
	lock_outline: "E899";
	lock_open: "E898";
	lock_clock: "EF57";
	lock: "E897";
	location_searching: "E1B7";
	location_pin: "F1DB";
	location_on: "E0C8";
	location_off: "E0C7";
	location_history: "E55A";
	location_disabled: "E1B6";
	location_city: "E7F1";
	local_taxi: "E559";
	local_shipping: "E558";
	local_see: "E557";
	local_restaurant: "E556";
	local_printshop: "E555";
	local_print_shop: "E555";
	local_post_office: "E554";
	local_police: "EF56";
	local_play: "E553";
	local_pizza: "E552";
	local_phone: "E551";
	local_pharmacy: "E550";
	local_parking: "E54F";
	local_offer: "E54E";
	local_movies: "E54D";
	local_mall: "E54C";
	local_library: "E54B";
	local_laundry_service: "E54A";
	local_hotel: "E549";
	local_hospital: "E548";
	local_grocery_store: "E547";
	local_gas_station: "E546";
	local_florist: "E545";
	local_fire_department: "EF55";
	local_drink: "E544";
	local_dining: "E556";
	local_convenience_store: "E543";
	local_car_wash: "E542";
	local_cafe: "E541";
	local_bar: "E540";
	local_attraction: "E53F";
	local_atm: "E53E";
	local_airport: "E53D";
	local_activity: "E53F";
	living: "F02B";
	live_tv: "E639";
	live_help: "E0C6";
	list_alt: "E0EE";
	list: "E896";
	liquor: "EA60";
	linked_camera: "E438";
	link_off: "E16F";
	link: "E157";
	linear_scale: "E260";
	line_weight: "E91A";
	line_style: "E919";
	line_axis: "EA9A";
	lightbulb_outline: "E90F";
	lightbulb: "E0F0";
	light_mode: "E518";
	light: "F02A";
	library_music: "E030";
	library_books: "E02F";
	library_add_check: "E9B7";
	library_add: "E02E";
	lens_blur: "F029";
	lens: "E3FA";
	legend_toggle: "F11B";
	leave_bags_at_home: "F21B";
	leak_remove: "E3F9";
	leak_add: "E3F8";
	leaderboard: "F20C";
	layers_clear: "E53C";
	layers: "E53B";
	launch: "E895";
	last_page: "E5DD";
	laptop_windows: "E321";
	laptop_mac: "E320";
	laptop_chromebook: "E31F";
	laptop: "E31E";
	language: "E894";
	landscape: "E3F7";
	lan: "EB2F";
	label_outline: "E893";
	label_off: "E9B6";
	label_important_outline: "E948";
	label_important: "E937";
	label: "E892";
	my_location: "E55C";
	my_library_music: "E030";
	my_library_books: "E02F";
	my_library_add: "E02E";
	music_video: "E063";
	music_off: "E440";
	music_note: "E405";
	museum: "EA36";
	multitrack_audio: "E1B8";
	multiple_stop: "F1B9";
	multiline_chart: "E6DF";
	mp: "E9C3";
	moving: "E501";
	movie_filter: "E43A";
	movie_creation: "E404";
	movie: "E02C";
	move_up: "EB64";
	move_to_inbox: "E168";
	move_down: "EB61";
	mouse: "E323";
	motorcycle: "E91B";
	motion_photos_paused: "E9C2";
	motion_photos_pause: "F227";
	motion_photos_on: "E9C1";
	motion_photos_off: "E9C0";
	motion_photos_auto: "F03A";
	mosque: "EAB2";
	more_vert: "E5D4";
	more_time: "EA5D";
	more_horiz: "E5D3";
	more: "E619";
	moped: "EB28";
	mood_bad: "E7F3";
	mood: "E7F2";
	monochrome_photos: "E403";
	monitor_weight: "F039";
	monitor_heart: "EAA2";
	monitor: "EF5B";
	money_off_csred: "F038";
	money_off: "E25C";
	money: "E57D";
	monetization_on: "E263";
	model_training: "F0CF";
	mode_standby: "F037";
	mode_of_travel: "E7CE";
	mode_night: "F036";
	mode_edit_outline: "F035";
	mode_edit: "E254";
	mode_comment: "E253";
	mode: "F097";
	mobiledata_off: "F034";
	mobile_screen_share: "E0E7";
	mobile_off: "E201";
	mobile_friendly: "E200";
	mms: "E618";
	missed_video_call: "E073";
	miscellaneous_services: "F10C";
	minimize: "E931";
	military_tech: "EA3F";
	microwave: "F204";
	mic_off: "E02B";
	mic_none: "E02A";
	mic_external_on: "EF5A";
	mic_external_off: "EF59";
	mic: "E029";
	messenger_outline: "E0CB";
	messenger: "E0CA";
	message: "E0C9";
	merge_type: "E252";
	merge: "EB98";
	menu_open: "E9BD";
	menu_book: "EA19";
	menu: "E5D2";
	memory: "E322";
	meeting_room: "EB4F";
	medication_liquid: "EA87";
	medication: "F033";
	medical_services: "F109";
	mediation: "EFA7";
	media_bluetooth_on: "F032";
	media_bluetooth_off: "F031";
	maximize: "E930";
	masks: "F218";
	markunread_mailbox: "E89B";
	markunread: "E159";
	mark_unread_chat_alt: "EB9D";
	mark_email_unread: "F18A";
	mark_email_read: "F18C";
	mark_chat_unread: "F189";
	mark_chat_read: "F18B";
	mark_as_unread: "E9BC";
	margin: "E9BB";
	maps_ugc: "EF58";
	maps_home_work: "F030";
	map: "E55B";
	manage_search: "F02F";
	manage_accounts: "F02E";
	man: "E4EB";
	male: "E58E";
	mail_outline: "E0E1";
	mail: "E158";
	numbers: "EAC7";
	now_widgets: "E1BD";
	now_wallpaper: "E1BC";
	notifications_paused: "E7F8";
	notifications_on: "E7F7";
	notifications_off: "E7F6";
	notifications_none: "E7F5";
	notifications_active: "E7F7";
	notifications: "E7F4";
	notification_important: "E004";
	notification_add: "E399";
	notes: "E26C";
	note_alt: "F040";
	note_add: "E89C";
	note: "E06F";
	not_started: "F0D1";
	not_listed_location: "E575";
	not_interested: "E033";
	not_accessible: "F0FE";
	north_west: "F1E2";
	north_east: "F1E1";
	north: "F1E0";
	nordic_walking: "E50E";
	no_transfer: "F1D5";
	no_stroller: "F1AF";
	no_sim: "E0CC";
	no_photography: "F1A8";
	no_meeting_room: "EB4E";
	no_meals_ouline: "F229";
	no_meals: "F1D6";
	no_luggage: "F23B";
	no_food: "F1A7";
	no_flash: "F1A6";
	no_encryption_gmailerrorred: "F03F";
	no_encryption: "E641";
	no_drinks: "F1A5";
	no_cell: "F1A4";
	no_backpack: "F237";
	no_accounts: "F03E";
	nights_stay: "EA46";
	nightlight_round: "EF5E";
	nightlight: "F03D";
	nightlife: "EA62";
	night_shelter: "F1F1";
	nfc: "E1BB";
	next_week: "E16A";
	next_plan: "EF5D";
	newspaper: "EB81";
	new_releases: "E031";
	new_label: "E609";
	network_wifi: "E1BA";
	network_ping: "EBCA";
	network_locked: "E61A";
	network_check: "E640";
	network_cell: "E1B9";
	nearby_off: "F03C";
	nearby_error: "F03B";
	near_me_disabled: "F1EF";
	near_me: "E569";
	navigation: "E55D";
	navigate_next: "E409";
	navigate_before: "E408";
	nature_people: "E407";
	nature: "E406";
	nat: "EF5C";
	output: "EBBE";
	outlined_flag: "E16E";
	outlet: "F1D4";
	outgoing_mail: "F0D2";
	outdoor_grill: "EA47";
	outbox: "EF5F";
	outbound: "E1CA";
	outbond: "F228";
	other_houses: "E58C";
	open_with: "E89F";
	open_in_new_off: "E4F6";
	open_in_new: "E89E";
	open_in_full: "F1CE";
	open_in_browser: "E89D";
	opacity: "E91C";
	online_prediction: "F0EB";
	ondemand_video: "E63A";
	offline_share: "E9C5";
	offline_pin: "E90A";
	offline_bolt: "E932";
	push_pin: "F10D";
	punch_clock: "EAA8";
	published_with_changes: "F232";
	publish: "E255";
	public_off: "F1CA";
	public: "E80B";
	psychology: "EA4A";
	production_quantity_limits: "E1D1";
	private_connectivity: "E744";
	privacy_tip: "F0DC";
	priority_high: "E645";
	print_disabled: "E9CF";
	print: "E8AD";
	price_check: "F04B";
	price_change: "F04A";
	preview: "F1C5";
	present_to_all: "E0DF";
	pregnant_woman: "E91E";
	precision_manufacturing: "F049";
	power_settings_new: "E8AC";
	power_off: "E646";
	power_input: "E336";
	power: "E63C";
	post_add: "EA20";
	portrait: "E416";
	portable_wifi_off: "E0CE";
	pool: "EB48";
	polymer: "E8AB";
	polyline: "EBBB";
	poll: "E801";
	policy: "EA17";
	point_of_sale: "F17E";
	podcasts: "F048";
	plus_one: "E800";
	plumbing: "F107";
	playlist_remove: "EB80";
	playlist_play: "E05F";
	playlist_add_circle: "E7E5";
	playlist_add_check_circle: "E7E6";
	playlist_add_check: "E065";
	playlist_add: "E03B";
	play_lesson: "F047";
	play_for_work: "E906";
	play_disabled: "EF6A";
	play_circle_outline: "E039";
	play_circle_filled: "E038";
	play_circle_fill: "E038";
	play_circle: "E1C4";
	play_arrow: "E037";
	plagiarism: "EA5A";
	place: "E55F";
	pix: "EAA3";
	pivot_table_chart: "E9CE";
	pinch: "EB38";
	pin_invoke: "E763";
	pin_end: "E767";
	pin_drop: "E55E";
	pin: "F045";
	pie_chart_outlined: "E6C5";
	pie_chart_outline: "F044";
	pie_chart: "E6C4";
	picture_in_picture_alt: "E911";
	picture_in_picture: "E8AA";
	picture_as_pdf: "E415";
	piano_off: "E520";
	piano: "E521";
	php: "EB8F";
	photo_size_select_small: "E434";
	photo_size_select_large: "E433";
	photo_size_select_actual: "E432";
	photo_library: "E413";
	photo_filter: "E43B";
	photo_camera_front: "EF69";
	photo_camera_back: "EF68";
	photo_camera: "E412";
	photo_album: "E411";
	photo: "E410";
	phonelink_setup: "E0DE";
	phonelink_ring: "E0DD";
	phonelink_off: "E327";
	phonelink_lock: "E0DC";
	phonelink_erase: "E0DB";
	phonelink: "E326";
	phone_paused: "E620";
	phone_missed: "E61F";
	phone_locked: "E61E";
	phone_iphone: "E325";
	phone_in_talk: "E61D";
	phone_forwarded: "E61C";
	phone_enabled: "E9CD";
	phone_disabled: "E9CC";
	phone_callback: "E649";
	phone_bluetooth_speaker: "E61B";
	phone_android: "E324";
	phone: "E0CD";
	phishing: "EAD7";
	pets: "E91D";
	pest_control_rodent: "F0FD";
	pest_control: "F0FA";
	personal_video: "E63B";
	personal_injury: "E6DA";
	person_search: "F106";
	person_remove_alt_1: "EF67";
	person_remove: "EF66";
	person_pin_circle: "E56A";
	person_pin: "E55A";
	person_outline: "E7FF";
	person_off: "E510";
	person_add_disabled: "E9CB";
	person_add_alt_1: "EF65";
	person_add_alt: "EA4D";
	person_add: "E7FE";
	person: "E7FD";
	perm_scan_wifi: "E8A9";
	perm_phone_msg: "E8A8";
	perm_media: "E8A7";
	perm_identity: "E8A6";
	perm_device_information: "E8A5";
	perm_device_info: "E8A5";
	perm_data_setting: "E8A4";
	perm_contact_calendar: "E8A3";
	perm_contact_cal: "E8A3";
	perm_camera_mic: "E8A2";
	percent: "EB58";
	people_outline: "E7FC";
	people_alt: "EA21";
	people: "E7FB";
	pentagon: "EB50";
	pending_actions: "F1BB";
	pending: "EF64";
	pedal_bike: "EB29";
	paypal: "EA8D";
	payments: "EF63";
	payment: "E8A1";
	pause_presentation: "E0EA";
	pause_circle_outline: "E036";
	pause_circle_filled: "E035";
	pause_circle: "E1A2";
	pause: "E034";
	pattern: "F043";
	password: "F042";
	party_mode: "E7FA";
	park: "EA63";
	paragliding: "E50F";
	panorama_wide_angle_select: "EF62";
	panorama_wide_angle: "E40F";
	panorama_vertical_select: "EF61";
	panorama_vertical: "E40E";
	panorama_photosphere_select: "E9CA";
	panorama_photosphere: "E9C9";
	panorama_horizontal_select: "EF60";
	panorama_horizontal: "E40D";
	panorama_fisheye: "E40C";
	panorama_fish_eye: "E40C";
	panorama: "E40B";
	pan_tool_alt: "EBB9";
	pan_tool: "E925";
	palette: "E40A";
	paid: "F041";
	pageview: "E8A0";
	pages: "E7F9";
	padding: "E9C8";
	quora: "EA98";
	quiz: "F04C";
	quickreply: "EF6C";
	quick_contacts_mail: "E0D0";
	quick_contacts_dialer: "E0CF";
	queue_play_next: "E066";
	queue_music: "E03D";
	queue: "E03C";
	question_mark: "EB8B";
	question_answer: "E8AF";
	query_stats: "E4FC";
	query_builder: "E8AE";
	qr_code_scanner: "F206";
	qr_code_2: "E00A";
	qr_code: "EF6B";
	rv_hookup: "E642";
	running_with_errors: "E51D";
	run_circle: "EF6F";
	rule_folder: "F1C9";
	rule: "F1C2";
	rtt: "E9AD";
	rsvp: "F055";
	rss_feed: "E0E5";
	rowing: "E921";
	router: "E328";
	route: "EACD";
	rounded_corner: "E920";
	roundabout_right: "EBA3";
	roundabout_left: "EB99";
	rotate_right: "E41A";
	rotate_left: "E419";
	rotate_90_degrees_cw: "EAAB";
	rotate_90_degrees_ccw: "E418";
	room_service: "EB49";
	room_preferences: "F1B8";
	room: "E8B4";
	roofing: "F201";
	roller_skating: "EBCD";
	rocket_launch: "EB9B";
	rocket: "EBA5";
	ring_volume: "E0D1";
	rice_bowl: "F1F5";
	reviews: "F054";
	restore_page: "E929";
	restore_from_trash: "E938";
	restore: "E8B3";
	restaurant_menu: "E561";
	restaurant: "E56C";
	restart_alt: "F053";
	reset_tv: "E9D9";
	request_quote: "F1B6";
	request_page: "F22C";
	report_problem: "E8B2";
	report_off: "E170";
	report_gmailerrorred: "F052";
	report: "E160";
	reply_all: "E15F";
	reply: "E15E";
	replay_circle_filled: "E9D8";
	replay_5: "E05B";
	replay_30: "E05A";
	replay_10: "E059";
	replay: "E042";
	repeat_one_on: "E9D7";
	repeat_one: "E041";
	repeat_on: "E9D6";
	repeat: "E040";
	reorder: "E8FE";
	remove_shopping_cart: "E928";
	remove_red_eye: "E417";
	remove_moderator: "E9D4";
	remove_from_queue: "E067";
	remove_done: "E9D3";
	remove_circle_outline: "E15D";
	remove_circle: "E15C";
	remove: "E15B";
	remember_me: "F051";
	refresh: "E5D5";
	reduce_capacity: "F21C";
	redo: "E15A";
	redeem: "E8B1";
	reddit: "EAA0";
	recycling: "E760";
	rectangle: "EB54";
	record_voice_over: "E91F";
	recommend: "E9D2";
	recent_actors: "E03F";
	receipt_long: "EF6E";
	receipt: "E8B0";
	real_estate_agent: "E73A";
	read_more: "EF6D";
	raw_on: "F050";
	raw_off: "F04F";
	rate_review: "E560";
	ramp_right: "EB96";
	ramp_left: "EB9C";
	ramen_dining: "EA64";
	railway_alert: "E9D1";
	radio_button_unchecked: "E836";
	radio_button_on: "E837";
	radio_button_off: "E836";
	radio_button_checked: "E837";
	radio: "E03E";
	radar: "F04E";
	r_mobiledata: "F04D";
	system_update_tv: "E8D7";
	system_update_alt: "E8D7";
	system_update: "E62A";
	system_security_update_warning: "F074";
	system_security_update_good: "F073";
	system_security_update: "F072";
	sync_problem: "E629";
	sync_lock: "EAEE";
	sync_disabled: "E628";
	sync_alt: "EA18";
	sync: "E627";
	synagogue: "EAB0";
	switch_video: "E41F";
	switch_right: "F1D2";
	switch_left: "F1D1";
	switch_camera: "E41E";
	switch_account: "E9ED";
	switch_access_shortcut_add: "E7E2";
	switch_access_shortcut: "E7E1";
	swipe_vertical: "EB51";
	swipe_up_alt: "EB35";
	swipe_up: "EB2E";
	swipe_right_alt: "EB56";
	swipe_right: "EB52";
	swipe_left_alt: "EB33";
	swipe_left: "EB59";
	swipe_down_alt: "EB30";
	swipe_down: "EB53";
	swipe: "E9EC";
	swap_vertical_circle: "E8D6";
	swap_vert_circle: "E8D6";
	swap_vert: "E8D5";
	swap_horizontal_circle: "E933";
	swap_horiz: "E8D4";
	swap_calls: "E0D7";
	surround_sound: "E049";
	surfing: "E515";
	support_agent: "F0E2";
	support: "EF73";
	supervisor_account: "E8D3";
	supervised_user_circle: "E939";
	superscript: "F112";
	sunny_snowing: "E819";
	sunny: "E81A";
	summarize: "F071";
	subway: "E56F";
	subtitles_off: "EF72";
	subtitles: "E048";
	subscriptions: "E064";
	subscript: "F111";
	subject: "E8D2";
	subdirectory_arrow_right: "E5DA";
	subdirectory_arrow_left: "E5D9";
	style: "E41D";
	stroller: "F1AE";
	strikethrough_s: "E257";
	streetview: "E56E";
	stream: "E9E9";
	straighten: "E41C";
	straight: "EB95";
	storm: "F070";
	storefront: "EA12";
	store_mall_directory: "E563";
	store: "E8D1";
	storage: "E1DB";
	stop_screen_share: "E0E3";
	stop_circle: "EF71";
	stop: "E047";
	sticky_note_2: "F1FC";
	stay_primary_portrait: "E0D6";
	stay_primary_landscape: "E0D5";
	stay_current_portrait: "E0D4";
	stay_current_landscape: "E0D3";
	start: "E089";
	stars: "E8D0";
	star_rate: "F0EC";
	star_purple500: "F09A";
	star_outline: "F06F";
	star_half: "E839";
	star_border_purple500: "F099";
	star_border: "E83A";
	star: "E838";
	stairs: "F1A9";
	stadium: "EB90";
	stacked_line_chart: "F22B";
	stacked_bar_chart: "E9E6";
	ssid_chart: "EB66";
	square_foot: "EA49";
	square: "EB36";
	sports_volleyball: "EA31";
	sports_tennis: "EA32";
	sports_soccer: "EA2F";
	sports_score: "F06E";
	sports_rugby: "EA2E";
	sports_motorsports: "EA2D";
	sports_mma: "EA2C";
	sports_martial_arts: "EAE9";
	sports_kabaddi: "EA34";
	sports_hockey: "EA2B";
	sports_handball: "EA33";
	sports_gymnastics: "EBC4";
	sports_golf: "EA2A";
	sports_football: "EA29";
	sports_esports: "EA28";
	sports_cricket: "EA27";
	sports_basketball: "EA26";
	sports_baseball: "EA51";
	sports_bar: "F1F3";
	sports: "EA30";
	spoke: "E9A7";
	splitscreen: "F06D";
	spellcheck: "E8CE";
	speed: "E9E4";
	speaker_phone: "E0D2";
	speaker_notes_off: "E92A";
	speaker_notes: "E8CD";
	speaker_group: "E32E";
	speaker: "E32D";
	space_dashboard: "E66B";
	space_bar: "E256";
	spa: "EB4C";
	south_west: "F1E5";
	south_east: "F1E4";
	south_america: "E7E4";
	south: "F1E3";
	source: "F1C4";
	soup_kitchen: "E7D3";
	sort_by_alpha: "E053";
	sort: "E164";
	social_distance: "E1CB";
	soap: "F1B2";
	snowshoeing: "E514";
	snowmobile: "E503";
	snowing: "E80F";
	snowboarding: "E513";
	snooze: "E046";
	snippet_folder: "F1C7";
	snapchat: "EA6E";
	sms_failed: "E626";
	sms: "E625";
	smoking_rooms: "EB4B";
	smoke_free: "EB4A";
	smartphone: "E32C";
	smart_toy: "F06C";
	smart_screen: "F06B";
	smart_display: "F06A";
	smart_button: "F1C1";
	slow_motion_video: "E068";
	slideshow: "E41B";
	sledding: "E512";
	skip_previous: "E045";
	skip_next: "E044";
	skateboarding: "E511";
	sip: "F069";
	single_bed: "EA48";
	sim_card_download: "F068";
	sim_card_alert: "E624";
	sim_card: "E32B";
	signpost: "EB91";
	signal_wifi_statusbar_null: "F067";
	signal_wifi_statusbar_connected_no_internet_4: "F066";
	signal_wifi_statusbar_4_bar: "F065";
	signal_wifi_off: "E1DA";
	signal_wifi_connected_no_internet_4: "F064";
	signal_wifi_bad: "F063";
	signal_wifi_4_bar_lock: "E1D9";
	signal_wifi_4_bar: "E1D8";
	signal_wifi_0_bar: "F0B0";
	signal_cellular_off: "E1D0";
	signal_cellular_null: "E1CF";
	signal_cellular_nodata: "F062";
	signal_cellular_no_sim: "E1CE";
	signal_cellular_connected_no_internet_4_bar: "E1CD";
	signal_cellular_connected_no_internet_0_bar: "F0AC";
	signal_cellular_alt: "E202";
	signal_cellular_4_bar: "E1C8";
	signal_cellular_0_bar: "F0A8";
	sick: "F220";
	shutter_speed: "E43D";
	shuffle_on: "E9E1";
	shuffle: "E043";
	shower: "F061";
	show_chart: "E6E1";
	shortcut: "F060";
	short_text: "E261";
	shopping_cart_checkout: "EB88";
	shopping_cart: "E8CC";
	shopping_basket: "E8CB";
	shopping_bag: "F1CC";
	shopify: "EA9D";
	shop_two: "E8CA";
	shop_2: "E19E";
	shop: "E8C9";
	shield_moon: "EAA9";
	shield: "E9E0";
	share_location: "F05F";
	share_arrival_time: "E524";
	share: "E80D";
	settings_voice: "E8C8";
	settings_system_daydream: "E1C3";
	settings_suggest: "F05E";
	settings_remote: "E8C7";
	settings_power: "E8C6";
	settings_phone: "E8C5";
	settings_overscan: "E8C4";
	settings_input_svideo: "E8C3";
	settings_input_hdmi: "E8C2";
	settings_input_composite: "E8C1";
	settings_input_component: "E8C0";
	settings_input_antenna: "E8BF";
	settings_ethernet: "E8BE";
	settings_display: "E8BD";
	settings_cell: "E8BC";
	settings_brightness: "E8BD";
	settings_bluetooth: "E8BB";
	settings_backup_restore: "E8BA";
	settings_applications: "E8B9";
	settings_accessibility: "F05D";
	settings: "E8B8";
	set_meal: "F1EA";
	sentiment_very_satisfied: "E815";
	sentiment_very_dissatisfied: "E814";
	sentiment_satisfied_alt: "E0ED";
	sentiment_satisfied: "E813";
	sentiment_neutral: "E812";
	sentiment_dissatisfied: "E811";
	sensors_off: "E51F";
	sensors: "E51E";
	sensor_window: "F1B4";
	sensor_door: "F1B5";
	send_to_mobile: "F05C";
	send_time_extension: "EADB";
	send_and_archive: "EA0C";
	send: "E163";
	sell: "F05B";
	self_improvement: "EA78";
	select_all: "E162";
	segment: "E94B";
	security_update_warning: "F05A";
	security_update_good: "F059";
	security_update: "F058";
	security: "E32A";
	search_off: "EA76";
	search: "E8B6";
	sd_storage: "E1C2";
	sd_card_alert: "F057";
	sd_card: "E623";
	sd: "E9DD";
	scuba_diving: "EBCE";
	screenshot: "F056";
	screen_share: "E0E2";
	screen_search_desktop: "EF70";
	screen_rotation: "E1C1";
	screen_lock_rotation: "E1C0";
	screen_lock_portrait: "E1BF";
	screen_lock_landscape: "E1BE";
	scoreboard: "EBD0";
	score: "E269";
	science: "EA4B";
	school: "E80C";
	schema: "E4FD";
	schedule_send: "EA0A";
	schedule: "E8B5";
	scatter_plot: "E268";
	scanner: "E329";
	scale: "EB5F";
	savings: "E2EB";
	saved_search: "EA11";
	save_as: "EB60";
	save_alt: "E171";
	save: "E161";
	satellite_alt: "EB3A";
	satellite: "E562";
	sanitizer: "F21D";
	sailing: "E502";
	safety_divider: "E1CC";
	two_wheeler: "E9F9";
	tv_off: "E647";
	tv: "E333";
	turned_in_not: "E8E7";
	turned_in: "E8E6";
	turn_slight_right: "EB9A";
	turn_slight_left: "EBA4";
	turn_sharp_right: "EBAA";
	turn_sharp_left: "EBA7";
	turn_right: "EBAB";
	turn_left: "EBA6";
	tungsten: "F07D";
	tune: "E429";
	tty: "F1AA";
	try: "F07C";
	trip_origin: "E57B";
	trending_up: "E8E5";
	trending_neutral: "E8E4";
	trending_flat: "E8E4";
	trending_down: "E8E3";
	travel_explore: "E2DB";
	translate: "E8E2";
	transit_enterexit: "E579";
	transgender: "E58D";
	transform: "E428";
	transfer_within_a_station: "E572";
	tram: "E571";
	train: "E570";
	traffic: "E565";
	track_changes: "E8E1";
	toys: "E332";
	tour: "EF75";
	touch_app: "E913";
	topic: "F1C8";
	tonality: "E427";
	toll: "E8E0";
	token: "EA25";
	toggle_on: "E9F6";
	toggle_off: "E9F5";
	today: "E8DF";
	toc: "E8DE";
	title: "E264";
	tire_repair: "EBC8";
	tips_and_updates: "E79A";
	timer_off: "E426";
	timer_3_select: "F07B";
	timer_3: "E424";
	timer_10_select: "F07A";
	timer_10: "E423";
	timer: "E425";
	timeline: "E922";
	timelapse: "E422";
	time_to_leave: "E62C";
	tiktok: "EA7E";
	thumbs_up_down: "E8DD";
	thumb_up_off_alt: "E9F3";
	thumb_up_alt: "E817";
	thumb_up: "E8DC";
	thumb_down_off_alt: "E9F2";
	thumb_down_alt: "E816";
	thumb_down: "E8DB";
	thermostat_auto: "F077";
	thermostat: "F076";
	theaters: "E8DA";
	theater_comedy: "EA66";
	texture: "E421";
	textsms: "E0D8";
	text_snippet: "F1C6";
	text_rotation_none: "E93F";
	text_rotation_down: "E93E";
	text_rotation_angleup: "E93D";
	text_rotation_angledown: "E93C";
	text_rotate_vertical: "E93B";
	text_rotate_up: "E93A";
	text_increase: "EAE2";
	text_format: "E165";
	text_fields: "E262";
	text_decrease: "EADD";
	terrain: "E564";
	terminal: "EB8E";
	temple_hindu: "EAAF";
	temple_buddhist: "EAB3";
	telegram: "EA6B";
	taxi_alert: "EF74";
	task_alt: "E2E6";
	task: "F075";
	tapas: "F1E9";
	tap_and_play: "E62B";
	takeout_dining: "EA74";
	tag_faces: "E420";
	tag: "E9EF";
	tablet_mac: "E331";
	tablet_android: "E330";
	tablet: "E32F";
	table_view: "F1BE";
	table_rows: "F101";
	table_restaurant: "EAC6";
	table_chart: "E265";
	table_bar: "EAD2";
	tab_unselected: "E8D9";
	tab: "E8D8";
	usb_off: "E4FA";
	usb: "E1E0";
	upload_file: "E9FC";
	upload: "F09B";
	upgrade: "F0FB";
	update_disabled: "E075";
	update: "E923";
	upcoming: "F07E";
	unsubscribe: "E0EB";
	unpublished: "F236";
	unfold_more: "E5D7";
	unfold_less: "E5D6";
	undo: "E166";
	unarchive: "E169";
	umbrella: "F1AD";
	u_turn_right: "EBA2";
	u_turn_left: "EBA1";
	vrpano: "F082";
	vpn_lock: "E62F";
	vpn_key_off: "EB7A";
	vpn_key: "E0DA";
	volunteer_activism: "EA70";
	volume_up: "E050";
	volume_off: "E04F";
	volume_mute: "E04E";
	volume_down_alt: "E79C";
	volume_down: "E04D";
	voicemail: "E0D9";
	voice_over_off: "E94A";
	voice_chat: "E62E";
	visibility_off: "E8F5";
	visibility: "E8F4";
	villa: "E586";
	vignette: "E435";
	view_week: "E8F3";
	view_timeline: "EB85";
	view_stream: "E8F2";
	view_sidebar: "F114";
	view_quilt: "E8F1";
	view_module: "E8F0";
	view_list: "E8EF";
	view_kanban: "EB7F";
	view_in_ar: "E9FE";
	view_headline: "E8EE";
	view_day: "E8ED";
	view_cozy: "EB75";
	view_compact_alt: "EB74";
	view_compact: "E42B";
	view_comfy_alt: "EB73";
	view_comfy: "E42A";
	view_comfortable: "E42A";
	view_column: "E8EC";
	view_carousel: "E8EB";
	view_array: "E8EA";
	view_agenda: "E8E9";
	videogame_asset_off: "E500";
	videogame_asset: "E338";
	videocam_off: "E04C";
	videocam: "E04B";
	video_stable: "F081";
	video_settings: "EA75";
	video_library: "E04A";
	video_label: "E071";
	video_file: "EB87";
	video_collection: "E04A";
	video_camera_front: "F080";
	video_camera_back: "F07F";
	video_call: "E070";
	vibration: "E62D";
	vertical_split: "E949";
	vertical_distribute: "E076";
	vertical_align_top: "E25A";
	vertical_align_center: "E259";
	vertical_align_bottom: "E258";
	verified_user: "E8E8";
	verified: "EF76";
	vaping_rooms: "EBCF";
	vape_free: "EBC6";
	vaccines: "E138";
	wysiwyg: "F1C3";
	wrong_location: "EF78";
	wrap_text: "E25B";
	workspaces_outline: "EA0F";
	workspaces_filled: "EA0D";
	workspaces: "E1A0";
	workspace_premium: "E7AF";
	work_outline: "E943";
	work_off: "E942";
	work: "E8F9";
	wordpress: "EA9F";
	woo_commerce: "EA6D";
	woman: "E13E";
	wine_bar: "F1E8";
	window: "F088";
	wifi_tethering_off: "F087";
	wifi_tethering_error_rounded: "F086";
	wifi_tethering_error: "EAD9";
	wifi_tethering: "E1E2";
	wifi_protected_setup: "F0FC";
	wifi_password: "EB6B";
	wifi_off: "E648";
	wifi_lock: "E1E1";
	wifi_find: "EB31";
	wifi_channel: "EB6A";
	wifi_calling_3: "F085";
	wifi_calling: "EF77";
	wifi: "E63E";
	widgets: "E1BD";
	where_to_vote: "E177";
	wheelchair_pickup: "F1AB";
	whatshot: "E80E";
	whatsapp: "EA9C";
	west: "F1E6";
	weekend: "E16B";
	wechat: "EA81";
	webhook: "EB92";
	web_stories: "E595";
	web_asset_off: "E4F7";
	web_asset: "E069";
	web: "E051";
	wc: "E63D";
	wb_twilight: "E1C6";
	wb_twighlight: "EA02";
	wb_sunny: "E430";
	wb_shade: "EA01";
	wb_iridescent: "E436";
	wb_incandescent: "E42E";
	wb_cloudy: "E42D";
	wb_auto: "E42C";
	waving_hand: "E766";
	waves: "E176";
	waterfall_chart: "EA00";
	water_drop: "E798";
	water_damage: "F203";
	water: "F084";
	watch_off: "EAE3";
	watch_later: "E924";
	watch: "E334";
	wash: "F1B1";
	warning_amber: "F083";
	warning: "E002";
	warehouse: "EBB8";
	wallpaper: "E1BC";
	wallet_travel: "E8F8";
	wallet_membership: "E8F7";
	wallet_giftcard: "E8F6";
	youtube_searched_for: "E8FA";
	yard: "F089";
	zoom_out_map: "E56B";
	zoom_out: "E900";
	zoom_in_map: "EB2D";
	zoom_in: "E8FF";
};
export type FrameControls = [
	keyof MaterialIconCodes,
	FrameControl
][];
export declare const ControlBar: ({ children, controls, actions, className, }: {
	className?: string;
	actions?: WindowActions;
	children?: ReactNode;
	controls?: FrameControls;
}) => import("react/jsx-runtime").JSX.Element;
export type RouteTable = [
	string,
	ReactNode
][];
export type DeskCtx = {
	nodes: IdNode[];
};
export type IdNode = [
	string,
	ReactNode
];
export declare const useDesk: () => DeskCtx | undefined;
export declare const useUpdateDesk: () => React.Dispatch<React.SetStateAction<DeskCtx>> | undefined;
export declare const Desk: ({ children, routeTable, initialPath, index, }: {
	initialPath?: string;
	children?: ReactNode;
	routeTable?: RouteTable;
	index?: ReactNode;
}) => import("react/jsx-runtime").JSX.Element;
export declare const Drag: (props: {
	dataType?: string;
	data?: string;
	children: ReactNode;
	className?: string;
	dropped?: (event: React.DragEvent<HTMLDivElement>) => void;
}) => import("react/jsx-runtime").JSX.Element;
export declare const DropTarget: (props: {
	children: ReactNode;
	action?: (data: string) => void;
	dataType?: string;
	dropEffect?: "copy" | "link" | "move" | "none";
}) => import("react/jsx-runtime").JSX.Element;
export declare function Dropzone({ action, iconCode, iconSize, highlightedIconCode, activeText, inactiveText, style, }: {
	style?: CSSProperties;
	action: (files: File[]) => void;
	iconCode?: keyof MaterialIconCodes;
	highlightedIconCode?: keyof MaterialIconCodes;
	iconSize?: string;
	activeText?: string;
	inactiveText?: string;
}): import("react/jsx-runtime").JSX.Element;
export declare const Error: ({ children }: {
	children: string;
}) => import("react/jsx-runtime").JSX.Element;
export declare const Frag: ({ children, id, }: {
	id?: string;
	children?: ReactNode;
}) => import("react/jsx-runtime").JSX.Element;
export declare const useFragId: () => string | undefined;
declare function useClickOutside(ref: React.MutableRefObject<HTMLElement | Document>, action: (e: Event) => void, options?: {
	ignoreFirstClick: boolean;
	outside: Document;
}): void;
export type CombinedEventMap = HTMLElementEventMap & WindowEventMap & DocumentEventMap;
declare function useEventListener<K extends keyof CombinedEventMap>(eventType: K, action: (e: CombinedEventMap[K]) => void, element?: HTMLElement | Document | Window | undefined): void;
declare function useRenderCount(): number;
declare function useCustomEventListener<E extends string = string, T = unknown>(eventType: E, action: (e: CustomEvent<T>) => void, options?: Partial<{
	element: HTMLElement | Document | Window;
	deps: React.DependencyList;
}>): void;
export type ReactContextContainer<T> = {
	ContextProvider: ({ children }: {
		children?: ReactNode;
	}) => JSX.Element;
	useCtx: () => T;
	useUpdateCtx: () => React.Dispatch<React.SetStateAction<T>>;
};
export type CustomEventHandler<T> = (event: CustomEvent<T>) => void;
export type GuiCtx = {
	windows: WinCtx[];
};
export type UpdateGuiCtx = React.Dispatch<React.SetStateAction<GuiCtx>>;
export declare const Reacts: {
	render: (node: import("react").ReactChild | import("react").ReactNode[], parent?: HTMLElement, container?: HTMLDivElement) => RenderControl;
	useDropzone: typeof useDropzone;
	toRoutes: (routes: RouteTable) => import("react").ReactNode[];
	createReactContext: <T extends object>(initial?: T) => ReactContextContainer<T>;
	dispatchCustomEvent: <T>(eventType: string, payload: T, element?: HTMLElement | Document | Window) => void;
	addCustomEventListener: <E extends string = string, T = unknown>(eventType: E, handler: CustomEventHandler<T>, options?: Partial<{
		element: HTMLElement | Document | Window;
		once: boolean;
	}>) => () => void;
	px: (value: number) => string | undefined;
	unPx: (value: string | undefined) => number | undefined;
	useGuiCtx: () => GuiCtx | undefined;
	useUpdateGuiCtx: () => UpdateGuiCtx | undefined;
	useClickOutside: typeof useClickOutside;
	useEventListener: typeof useEventListener;
	useRenderCount: typeof useRenderCount;
	useAddToDesk: () => (node: import("react").ReactNode, id?: string) => string | number | boolean | Iterable<import("react").ReactNode> | import("react/jsx-runtime").JSX.Element;
	useRemoveFromDesk: () => () => void;
	useNav: () => (path: string) => void;
	usePreviousPath: () => any;
	useBringToFront: () => (id?: string | undefined) => void;
	useCustomEventListener: typeof useCustomEventListener;
	useAsyncEffect: (func: () => void | (() => void) | Promise<void | (() => void)>, deps?: import("react").DependencyList, destructor?: () => void) => Promise<void>;
	useIsFocused: () => boolean | undefined;
	useKeyboardListener: (keyActions: KeyActions, options?: InputListenOptions) => void;
};
export declare const Border: ({ title, children, style, defaultDisclosed, collapsable, onDiscloserChange, alwaysShowChildren, resizable, onResize, }: {
	onResize?: (bbox: DOMRect) => void;
	resizable?: boolean;
	defaultDisclosed?: boolean;
	collapsable?: boolean;
	style?: React.CSSProperties;
	title?: ReactNode;
	children?: ReactNode;
	alwaysShowChildren?: boolean;
	onDiscloserChange?: (disclosed: boolean) => void;
}) => import("react/jsx-runtime").JSX.Element;
export declare const ButtonGroup: ({ actions, count, style, buttonStyle, }: {
	style?: CSSProperties;
	buttonStyle?: CSSProperties;
	actions: Record<string, () => void>;
	count?: number;
}) => import("react/jsx-runtime").JSX.Element;
export type CanvasPainter = (canvas: HTMLCanvasElement) => Promise<() => void> | undefined | (() => void) | void;
export declare const Canvas: ({ painter, width, height, title, style, }: {
	title?: string;
	style?: React.CSSProperties;
	width?: number;
	height?: number;
	painter?: CanvasPainter;
}) => import("react/jsx-runtime").JSX.Element;
export declare const ContentEditable: ({ id, onChange, onClick, onContextMenu, style, value, autoFocus, onMouseUp, tabIndex, onKeyDown, editable, title, theme, }: {
	theme?: string;
	id?: string;
	title?: string;
	editable?: boolean;
	tabIndex?: number;
	autoFocus?: boolean;
	value?: string;
	style?: React.CSSProperties;
	onChange?: (value: string | undefined) => void;
	onMouseUp?: MouseEventHandler<HTMLElement>;
	onKeyDown?: KeyboardEventHandler<HTMLElement>;
	onClick?: MouseEventHandler<HTMLElement>;
	onContextMenu?: MouseEventHandler<HTMLElement>;
}) => import("react/jsx-runtime").JSX.Element;
export declare class ErrorBoundary extends React.Component {
	constructor(props: {} | Readonly<{}>);
	static getDerivedStateFromError(error: Error): {
		hasError: boolean;
		message: string;
		stack: string | undefined;
	};
	componentDidCatch(error: unknown, info: unknown): void;
	render(): any;
}
export type FormValueType = "string" | "number" | "boolean" | "color";
export declare const INPUT_VALUE_CONTROLS: Record<FormValueType, (key: string, value?: string) => JSX.Element>;
export declare const formEntryToFormLine: (key: string, valueType: FormValueType) => (import("react/jsx-runtime").JSX.Element | ((key: string, value?: string) => JSX.Element))[];
export declare const Form: <R extends Record<string, FormValueType>>({ format, initial, onChange, onSubmit, submitText, }: {
	readonly format: R;
	readonly initial?: Partial<Record<keyof R, string>>;
	onChange?: (record: Partial<Record<keyof R, string>>) => void;
	onSubmit?: (record: Partial<Record<keyof R, string>>) => void;
	submitText?: string;
}) => import("react/jsx-runtime").JSX.Element;
export declare const Frame: ({ children, routes, type, initialPath, index, }: {
	index?: ReactNode;
	initialPath?: string;
	children: ReactNode;
	routes?: ReactNode;
	type?: "hash" | "memory";
}) => JSX.Element;
export declare const Grid: ({ children, direction, count, style, className, cellSize, gap, }: {
	gap?: string;
	cellSize?: string | string[];
	className?: string;
	count?: number;
	style?: React.CSSProperties;
	direction?: "row" | "column";
	children?: ReactNode;
}) => import("react/jsx-runtime").JSX.Element;
export declare const HighlightableIcon: ({ text, highlighted, iconCode, highlightedIconCode, iconSize, }: {
	iconSize?: string;
	iconCode?: keyof MaterialIconCodes;
	highlightedIconCode?: keyof MaterialIconCodes;
	highlighted?: boolean;
	text: string;
}) => import("react/jsx-runtime").JSX.Element;
export declare const Hover: ({ setShow, children, className, }: {
	className?: string;
	setShow?: React.Dispatch<React.SetStateAction<boolean>>;
	children: ReactNode;
}) => import("react/jsx-runtime").JSX.Element;
/** requires material-icon 'google' font
 *
 *  @import url(https://fonts.googleapis.com/css2?family=Material+Icons);
 */
export declare const Icon: ({ children, style, onClick, code, }: {
	code?: keyof MaterialIconCodes;
	onClick?: (event: React.MouseEvent<HTMLElement, MouseEvent>) => void;
	children?: keyof MaterialIconCodes;
	style?: ReactCssProperties;
}) => import("react/jsx-runtime").JSX.Element;
export declare function ImageDropzone({ action, activeText, text, }: {
	text?: string;
	activeText?: string;
	action: (files: File[]) => void;
}): import("react/jsx-runtime").JSX.Element;
export declare const ImageWindow: ({ src }: {
	src: ImageSrc;
}) => import("react/jsx-runtime").JSX.Element;
export type ImageSrc = File;
export type MenuItems = MenuItem[];
export type MenuItem = [
	content: ReactNode,
	action: () => void,
	toolTip?: ReactChild
];
export declare const Menu: ({ items, direction, className, }: {
	className?: string;
	direction?: "row" | "column";
	items: MenuItems;
}) => import("react/jsx-runtime").JSX.Element;
export declare const OpenImageWindow: () => import("react/jsx-runtime").JSX.Element;
export declare const RecordToGrid: <T extends ReactNode>({ value, }: {
	value: Record<string, T>;
}) => import("react/jsx-runtime").JSX.Element;
export declare const TextScreen: ({ text, actions, style, }: {
	style?: CSSProperties;
	text: string;
	actions?: Record<string, () => void>;
}) => import("react/jsx-runtime").JSX.Element;
export type UpdateWinCtx = React.Dispatch<React.SetStateAction<WinCtx>>;
export declare const WIN_CTX: React.Context<WinCtx | undefined>;
export declare const UPDATE_WIN_CTX: React.Context<UpdateWinCtx | undefined>;
export declare const useWinCtx: () => WinCtx | undefined;
export declare const useUpdateWinCtx: () => UpdateWinCtx | undefined;
export declare const Win: ({ children, style, title, controls, className, clickBringsToFont, resizeable, }: {
	resizeable?: boolean;
	clickBringsToFont?: boolean;
	className?: string;
	children?: ReactNode;
	style?: CSSProperties;
	title?: string;
	controls?: FrameControls;
}) => import("react/jsx-runtime").JSX.Element;
export type State<T> = UseBoundStore<StoreApi<T>>;
export type StateUpdaterParam<T> = Partial<T> | ((state: T) => Partial<T> | void);
export type StateUpdater<T> = (doc: StateUpdaterParam<T>) => void;
export type StateGetter<T> = () => T;
export type StateAndUpdater<T> = readonly [
	State<T>,
	StateUpdater<T>,
	StateGetter<T>
];
export declare const States: {
	createState: <T>(init: T | (() => T)) => StateAndUpdater<T>;
	createStateUpdater: <T>(store: import("zustand").UseBoundStore<import("zustand").StoreApi<T>>) => StateUpdater<T>;
	updateState: <T>(doc: StateUpdaterParam<T>, store: import("zustand").UseBoundStore<import("zustand").StoreApi<T>>) => void;
};
export declare const createState: <T>(init: T | (() => T)) => StateAndUpdater<T>;
export declare const createStateUpdater: <T>(store: UseBoundStore<StoreApi<T>>) => StateUpdater<T>;
export declare const updateState: <T>(doc: StateUpdaterParam<T>, store: UseBoundStore<StoreApi<T>>) => void;
export type ActionMap = Record<string, () => void | unknown | Promise<void | unknown>>;
export declare const CenteredPopup: ({ name, onClose, children, options, }: {
	children: ReactNode;
	name: string;
	onClose: () => void;
	options?: Partial<{
		escapeCloses: boolean;
	}>;
}) => import("react/jsx-runtime").JSX.Element;
export declare const ContextMenu: ({ name, actionMap, style, itemStyle, }: {
	actionMap: Record<string, () => void>;
	name: string;
	style?: CSSProperties;
	itemStyle?: CSSProperties;
}) => import("react/jsx-runtime").JSX.Element;
export declare const PopupContentDisplay: ({ name, moveEnabled, x, y, content, showFrame, }: {
	showFrame: boolean;
	content: ReactNode;
	x: number;
	y: number;
	name: string;
	moveEnabled: boolean;
}) => import("react/jsx-runtime").JSX.Element;
export declare const PopupDisplay: () => import("react/jsx-runtime").JSX.Element;
export type PopupState = {
	content: ReactNode;
	x: number;
	y: number;
	moveEnabled: boolean;
	visible: boolean;
	offsetX: number;
	offsetY: number;
	showFrame: boolean;
	right: string;
};
export declare const Popups: {
	openPopup: (content: import("react").ReactNode, options?: Partial<{
		name: string;
		x: number;
		y: number;
		right: string;
		visible: boolean;
		showFrame: boolean;
	}>) => string;
	closePopup: (name: string) => void;
	calcCenterPopup: (w: number, h: number) => {
		x: number;
		y: number;
	};
	usePopupState: State<{
		popups: Record<string, Partial<PopupState>>;
		x: number;
		y: number;
	}>;
	isPopupOpen: (name: string) => boolean;
	openCenteredPopup: (content: import("react").ReactNode, options?: Partial<{
		name: string;
		x: number;
		y: number;
		showFrame: boolean;
		onClose: () => void;
		escapeCloses: boolean;
	}>) => string;
	centerPopup: (name: string, container: HTMLElement) => void;
	isPopupVisible: (name: string) => boolean | undefined;
	hidePopup: (name: string) => void;
	showPopup: (name: string) => void;
};
export declare const centerPopup: (name: string, container: HTMLElement) => void;
export declare const closePopup: (name: string) => void;
export declare const isPopupOpen: (name: string) => boolean;
export declare const openCenteredPopup: (content: ReactNode, options?: Partial<{
	name: string;
	x: number;
	y: number;
	showFrame: boolean;
	onClose: () => void;
	escapeCloses: boolean;
}>) => string;
export declare const openContextMenu: (event: React.MouseEvent, actionMap: ActionMap, options?: Partial<{
	style?: CSSProperties;
	itemStyle?: CSSProperties;
	offsetX: number;
	offsetY: number;
}>) => void;
export declare const openPopup: (content: ReactNode, options?: Partial<{
	name: string;
	x: number;
	y: number;
	right: string;
	visible: boolean;
	showFrame: boolean;
}>) => string;
export type ReactStateSetter<T = unknown> = React.Dispatch<React.SetStateAction<T>>;
export type RenderControl = {
	dispose: () => void;
	root: ReactDOM.Root;
	container: HTMLElement;
};
export type RenderState = {
	control: RenderControl;
	actions: WindowActions;
};
export type RenderGroup = RenderState[];
export type LockFn<T = unknown> = () => Promise<T> | T;
export type LockEntry = {
	fn: LockFn;
	id: string;
};
export declare const useLockState: State<{
	locks: Record<string, LockEntry[]>;
}>, updateLockState: StateUpdater<{
	locks: Record<string, LockEntry[]>;
}>, getLockState: StateGetter<{
	locks: Record<string, LockEntry[]>;
}>;
export declare const lock: <T>(fn: LockFn<T>, options?: Partial<{
	maxCycles: number;
	cycleMs: number;
	name: string;
}>) => Promise<T>;
export declare const pasteTextAtCurrentCursorPosition: (text: string) => void;
export declare const resizeElementToContent: (element: HTMLElement, content: string, style?: CSSProperties) => readonly [
	number,
	number
] | undefined;
export declare const toString: (value: unknown) => string | undefined;
export declare const useClickOutside: typeof useClickOutside, useEventListener: typeof useEventListener, useGuiCtx: () => GuiCtx | undefined, useRenderCount: typeof default, useUpdateGuiCtx: () => UpdateGuiCtx | undefined, useAddToDesk: () => (node: import("react").ReactNode, id?: string) => string | number | boolean | Iterable<import("react").ReactNode> | import("react/jsx-runtime").JSX.Element, useRemoveFromDesk: () => () => void, useNav: () => (path: string) => void, usePreviousPath: () => any, useBringToFront: () => (id?: string | undefined) => void, useDropzone: typeof import("react-dropzone").useDropzone, useKeyboardListener: (keyActions: KeyActions, options?: InputListenOptions) => void, useIsFocused: () => boolean | undefined, useCustomEventListener: typeof useCustomEventListener, useAsyncEffect: (func: () => void | (() => void) | Promise<void | (() => void)>, deps?: import("react").DependencyList, destructor?: () => void) => Promise<void>, dispatchCustomEvent: <T>(eventType: string, payload: T, element?: HTMLElement | Document | Window) => void, px: (value: number) => string | undefined, unPx: (value: string | undefined) => number | undefined;
export type ClearWhen = "tick" | "never";
export type Sample = {
	name: string;
	values: unknown[];
	logEnabled: boolean;
	lastLogged: number;
	clearAfter: ClearWhen;
	frequencySecs: number;
	maxSamples: number;
};
export declare const Samples: {
	create: (sample?: Partial<Sample>) => Sample;
	names: () => string[];
	add: (value: unknown, sample?: Partial<Sample>) => Sample;
	set: (name: string, value: number) => void;
	log: (name: string) => void;
	clear: (name: string) => void;
	all: () => Sample[];
};
export type Stat = {
	name: string;
	values: number[];
	count: number;
	maxSamples: number;
};
export declare const pushName: (name: string) => boolean;
export declare const popName: () => void;
export declare const pushPopName: <T>(name: string, producer: () => T) => T;
export declare const count: (name: string) => number;
export declare const enable: (enabled?: boolean) => void;
export declare const Stats: {
	sumAdd: (name: string, value: number) => void;
	sumSubtract: (name: string, value: number) => void;
	names: () => string[];
	add: (value: number, options?: Partial<{
		maxSamples: number;
	}>) => void;
	set: (name: string, value: number) => void;
	avg: (name: string) => number;
	sum: (name: string) => number;
	clear: (name?: string) => void;
	time: <T>(name: string, f: () => T, options?: Partial<{
		maxSamples: number;
	}>) => T;
	get: (name: string) => Stat;
	count: (name: string) => number;
	pushName: (name: string) => boolean;
	popName: () => void;
	logStats: (log?: (message: unknown) => void) => void;
	enable: (enabled?: boolean) => void;
};
export type PerformanceMemory = {
	jsHeapSizeLimit: number;
	totalJSHeapSize: number;
	usedJSHeapSize: number;
};
export declare const memoryUsedMb: () => number;
export declare const Performances: {
	memoryUsedMb: () => number;
};
export declare const TickStats: {
	createTickStatsTicker: ({ parent, statUpdater: statUpdater, }: {
		statUpdater?: StatUpdater | StatUpdater[];
		parent: HTMLElement;
	}) => Ticker;
};
export type TickToStat = (tick: Tick) => string;
export type StatUpdater = {
	statName: string;
	tickToStat: TickToStat;
};
export declare const time: <T>(name: string, f: () => T, options?: Partial<{
	maxSamples: number;
}>) => T;
declare function hashFnv32a({ str, seed }: {
	str: string;
	seed?: number;
}): number;
declare function match(s1: string | RegExp, s2: string | RegExp): boolean | undefined;
export declare const Strings: {
	match: typeof match;
	hashFnv32a: typeof hashFnv32a;
	toBytes: (str: string) => Blob;
	toHex: (num: number) => string;
};
export declare const isErrorLike: (maybe: unknown) => maybe is ErrorLike, isErrorType: (value: unknown) => value is Error, tryValue: <T>(value: T | Error, message?: string) => T, orError: <T>(f: () => T, options?: Partial<{
	message?: string;
	cause?: unknown;
}>) => T | Error, chain: <T>(initial: T, mappers: ((v: T) => T)[]) => T, entries: <O extends object, K extends keyof O, V = O[K]>(obj: O) => [
	K,
	V
][], filter: <O extends object, K extends keyof O, V extends O[K]>(obj: O, predicate: (key: K, value: V) => boolean) => [
	K,
	V
][], first: <O, T extends O>(obj: Readonly<O[] | O | Iterator<O, T>>, typeGuard?: TypeGuard<T>) => T | undefined, last: <T>(obj: Readonly<T[]>) => T | undefined, forEach: <O extends object, K extends keyof O>(obj: O, consumer: (key: K, value: O[K]) => void, errorHandler?: (error: unknown, key: K, value: O[K]) => void) => void, iff: <T, R>(value: T, mapper: (v: NonNullable<T>) => R) => R | undefined, orElse: <T>(o: T, e: T) => T, removeUndefinedValues: <T extends object>(obj: object) => Partial<T>, iffTyped: <T, R, G>(typeGuard: (maybe: unknown) => maybe is G, value: T, mapper: (v: T & G) => R) => R | undefined, isDefined: <T>(obj: T | undefined | null) => obj is NonNullable<T>, isUndefined: <T>(obj: T | undefined | null) => obj is undefined, omit: <K extends string | number, T extends {
	[k in K]: unknown;
}>(object: T, key: K) => Omit<T, K>, omitUnsafe: <K extends string | number, T extends {
	[k in K]: unknown;
}>(object: T, key: K) => Omit<T, K>, toMany: <T>(obj: T | T[] | Iterable<T>) => T[], fromEntries: <K extends string | number | symbol, V>(entries: readonly (readonly [
	K,
	V
])[]) => Record<K, V>, safe: <R>(producer: () => R, options?: Partial<{
	quiet: boolean;
	def: R;
	onError: ValueProducer<string>;
}>) => R | undefined, safeAsync: <R>(producer: () => Promise<R> | R, options?: Partial<{
	quiet: boolean;
	def: R;
	onError: ValueProducer<string>;
}>) => Promise<R | undefined>, mapValue: <T, R>(value: T, mapper: (value: T) => R) => R, headOf: <O, T extends O>(obj: Readonly<O[] | O | Iterator<O, T>>, typeGuard?: TypeGuard<T>) => T | undefined, tailOf: <O>(obj: O[]) => O[] | undefined, restOf: <O>(obj: O[]) => O[] | undefined, times: typeof times, isIterator: <T>(maybe: unknown) => maybe is Iterator<T>, toMultiMap: <K extends string | number, T>(maps: Record<K, T>[], options?: Partial<{
	compact: boolean;
}>) => Record<K, T[]>, timesGen: typeof timesGen, isIterable: typeof isIterable, isArrayLike: <T>(maybe: unknown) => maybe is ArrayLike<T>, iffBrowser: <T>(producer: () => T) => T | undefined, isBrowser: () => boolean, toPromise: <T>(producer: (callback: () => void) => T) => Promise<T>, all: {
	<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>;
	<T extends readonly unknown[] | [
	]>(values: T): Promise<{
		-readonly [P in keyof T]: Awaited<T[P]>;
	}>;
}, isFunction: (maybe: unknown) => maybe is Function, isEmpty: (value?: string | boolean | number | undefined) => boolean, isNotEmpty: (value?: string | boolean | number | undefined) => boolean, waitTimeout: (ms: number) => Promise<unknown>, toBoolean: (value: string | undefined) => boolean;

export {};
