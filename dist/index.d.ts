// Generated by dts-bundle-generator v8.0.1

import { AbstractMesh, BoundingBox, Camera, Color3, Color4, Constants, Engine, GlowLayer, ICanvasRenderingContext, IGlowLayerOptions, IParticleSystem, Mesh, Node, PBRMaterial, Scene, SolidParticleSystem, Sprite, SpriteManager, StandardMaterial, Texture, Vector3 } from 'babylonjs';
import QixColor from 'color';

export type WH = [
	number,
	number
];
export type WHD = [
	number,
	number,
	number
];
export type Ratio = number;
export type PointObject = PointObject1 | PointObject2 | PointObject3 | PointObject4;
export type PointObject1 = {
	x: number;
};
export type PointObject2 = PointObject1 & {
	y: number;
};
export type PointObject3 = PointObject2 & {
	z: number;
};
export type PointObject4 = PointObject3 & {
	w: number;
};
export type Vec = Vec0 | Vec1 | Vec2 | Vec3 | Vec4;
export type Vec0 = readonly number[];
export type Vec1 = readonly [
	number
];
export type Vec2 = readonly [
	number,
	number
];
export type Vec3 = readonly [
	number,
	number,
	number
];
export type Vec4 = readonly [
	number,
	number,
	number,
	number
];
export type Point = Point0 | (PointObject | Vec);
export type Point0 = Point1 | number;
export type Point1 = Point2 | (PointObject1 | Vec1);
export type Point2 = Point3 | (PointObject2 | Vec2);
export type Point3 = Point4 | (PointObject3 | Vec3);
export type Point4 = PointObject4 | Vec4;
export type XY = Vec2;
export type XYA = Vec3;
export type XYZ = Vec3;
export type XYZW = Vec4;
export type XYZA = Vec4;
export type Transform3 = {
	position: Point3;
	rotation: Point3;
	scale: Point3;
};
export declare const add: (a: number, b: number) => number;
export declare function add0(a: Point0, b: Point0): Point0;
export declare function add1(a: Point1, b: Point1): Point1;
export declare function add2(a: Point2, b: Point2): Point2;
export declare function add3(a: Point3, b: Point3): Point3;
export declare function add4(a: Point4, b: Point4): Point4;
export declare function addPoint(a: Point, b: Point): Point0;
export declare const aOf: <T>(pointVector: T[]) => T;
/**
 * blend two points via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha 0..1
 */
export declare function blend(a: number, b: number, alpha: number): number;
/**
 * blend two points via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha 0..1
 */
export declare function blend0(a: Point0, b: Point0, alpha: Point0): Point0;
/**
 * blend two point1s via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha
 */
export declare function blend1(a: Point1, b: Point1, alpha: Point1): Point1;
/**
 * blend two point2s via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha
 */
export declare function blend2(a: Point2, b: Point2, alpha: Point2): Point2;
/**
 * blend two point3s via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha
 */
export declare function blend3(a: Point3, b: Point3, alpha: Point3): Point3;
/**
 * blend two point3s via alpha
 * 0 = 100% a
 * 1 = 100% b
 * @param a
 * @param b
 * @param alpha
 */
export declare function blend4(a: Point4, b: Point4, alpha: Point4): Point4;
export declare function blendPoint(a: Point, b: Point, alpha: Point): Point;
export declare const bOf: <T>(pointVector: T[]) => T;
export declare function clamp(num: number, min: number, max: number): number;
export declare const cOf: <T>(pointVector: T[]) => T;
export declare const contains: (point: Point, needle: number) => boolean;
export declare function distance(a: number, b: number): number;
export declare function distance0(a: Point0, b: Point0): number;
export declare function distance1(a: Point1, b: Point1): number;
export declare function distance2(a: Point2, b: Point2): number;
export declare function distance3(a: Point3, b: Point3): number;
export declare function distance4(a: Point4, b: Point4): number;
export declare function distancePoint(a: Point, b: Point): number;
export declare function distancePoints2(points: Point2[]): number;
export declare function divide(a: number, b: number): number;
export declare function divide0(a: Point0, b: Point0): Point0;
export declare function divide1(a: Point1, b: Point1): Point1;
export declare function divide2(a: Point2, b: Point2): Point2;
export declare function divide3(a: Point3, b: Point3): Point3;
export declare function divide4(a: Point4, b: Point4): Point4;
export declare const dividePoint: (a: Point, b: Point) => Point;
export declare const dOf: <T>(pointVector: T[]) => T;
export declare const eOf: <T>(pointVector: T[]) => T;
export declare function isPoint(maybe: unknown): maybe is Point;
export declare function isPoint0(maybe: unknown): maybe is Point0;
export declare function isPoint1(maybe: unknown): maybe is Point1;
export declare function isPoint2(maybe: unknown): maybe is Point2;
export declare function isPoint3(maybe: unknown): maybe is Point3;
export declare function isPoint4(maybe: unknown): maybe is Point4;
export declare function isPointObject1(maybe: unknown): maybe is PointObject1;
export declare function isPointObject2(maybe: unknown): maybe is PointObject2;
export declare function isPointObject3(maybe: unknown): maybe is PointObject3;
export declare function isPointObject4(maybe: unknown): maybe is PointObject4;
export declare function isVec(maybe: unknown): maybe is Vec;
export declare function isVec0(maybe: unknown): maybe is Vec0;
export declare function isVec1(maybe: unknown): maybe is Vec1;
export declare function isVec2(maybe: unknown): maybe is Vec2;
export declare function isVec3(maybe: unknown): maybe is Vec3;
export declare function isVec4(maybe: unknown): maybe is Vec4;
export declare function jsonToPoint3(json: string): Point3;
export declare function length0(p: Point0): number;
export declare function length1(p: Point1): number;
export declare function length2(p: Point2): number;
export declare function length3(p: Point3): number;
export declare function length4(p: Point4): number;
export declare function lengthPoint(p: Point): number;
export declare function lerp(v0: number, v1: number, amount: number): number;
export declare const lerp0: (a: Point0, b: Point0, alpha: number) => Point0;
export declare const lerp1: (a: Point1, b: Point1, alpha: number) => Point1;
export declare const lerp2: (a: Point2, b: Point2, alpha: number) => Point2;
export declare const lerp3: (a: Point3, b: Point3, alpha: number) => Point3;
export declare const lerp4: (a: Point4, b: Point4, alpha: number) => Point4;
export declare const lerpPoint: (a: Point, b: Point, alpha: number) => number | PointObject1 | Vec1 | Vec2 | Vec3 | Vec4;
export declare function midPoint3(a: Point3, b: Point3): Point3;
export declare function multiply(a: number, b: number): number;
export declare function multiply0(a: Point0, b: Point0): Point0;
export declare function multiply1(a: Point1, b: Point1): Point1;
export declare function multiply2(a: Point2, b: Point2): Point2;
export declare function multiply3(a: Point3, b: Point3): Point3;
export declare function multiply4(a: Point4, b: Point4): Point4;
export declare function multiplyPoint(a: Point, b: Point): Point;
export declare function normalize0(p: Point0): Point0;
export declare function normalize1(p: Point1): Point1;
export declare function normalize2(p: Point2): Point2;
export declare function normalize3(p: Point3): Point3;
export declare function normalize4(p: Point4): Point4;
export declare const normalizePoint: (point: Point) => Point;
export declare function point3ToJson(point3: Point3): string;
export declare const quant: ({ v, q, s }: {
	v: number;
	q: number;
	s?: number;
}) => number;
export declare const scaler: (scale: number) => (value: number) => number;
export declare const scaler0: (scale: Point0) => (value: Point0) => Point0;
export declare const scaler1: (scale: Point1) => (value: Point1) => Point1;
export declare const scaler2: (scale: Point2) => (value: Point2) => Point2;
export declare const scaler3: (scale: Point3) => (value: Point3) => Point3;
export declare const scaler4: (scale: Point4) => (value: Point4) => Point4;
export declare const scalerPoint: (scale: Point) => ((value: Point0) => Point0) | ((value: Point1) => Point1) | ((value: Point2) => Point2) | ((value: Point3) => Point3) | ((value: Point4) => Point4);
export declare function subtract(a: number, b: number): number;
export declare function subtract0(a: Point0, b: Point0): Point0;
export declare function subtract1(a: Point1, b: Point1): Point1;
export declare function subtract2(a: Point2, b: Point2): Point2;
export declare function subtract3(a: Point3, b: Point3): Point3;
export declare function subtract4(a: Point4, b: Point4): Point4;
export declare function subtractPoint(a: Point, b: Point): Point;
export declare function toVec(point: Point): Vec;
/**
 * Promotes number to array
 */
export declare function toVec0(point: Point0): Vec0;
export declare function toVec1(point: Point1): Vec1;
export declare function toVec2(point: Point2): Vec2;
export declare function toVec3(point: Point3): Vec3;
export declare function toVec4(source: Point): Vec4;
export declare const translater: (a: number) => (b: number) => number;
export declare const translater0: (translatePoint: Point0) => (pos: Point0) => Point0;
export declare const translater1: (translatePoint: Point1) => (pos: Point1) => Point1;
export declare const translater2: (translatePoint: Point2) => (pos: Point2) => Point2;
export declare const translater3: (translatePoint: Point3) => (pos: Point3) => Point3;
export declare const translater4: (translatePoint: Point4) => (pos: Point4) => Point4;
export declare const translaterPoint: (translatePoint: Point) => (position: Point) => Point;
export declare function wOf(point: Point): number;
export declare function xOf(point: Point): number;
export declare function yOf(point: Point): number;
export declare function zOf(point: Point): number;
declare function length(p: number): number;
declare function midPoint2(a: Point2, b: Point2): Point2;
export declare const Maths: {
	toTransform3: (o3: Partial<Transform3>) => Transform3;
	add: (a: number, b: number) => number;
	add0: typeof add0;
	add1: typeof add1;
	add2: typeof add2;
	add3: typeof add3;
	add4: typeof add4;
	addPoint: typeof addPoint;
	blend: typeof blend;
	blend0: typeof blend0;
	blend1: typeof blend1;
	blend2: typeof blend2;
	blend3: typeof blend3;
	blend4: typeof blend4;
	blendPoint: typeof blendPoint;
	clamp: typeof clamp;
	contains: (point: Point, needle: number) => boolean;
	distance: typeof distance;
	distance0: typeof distance0;
	distance1: typeof distance1;
	distance2: typeof distance2;
	distance3: typeof distance3;
	distance4: typeof distance4;
	distancePoint: typeof distancePoint;
	divide: typeof divide;
	divide0: typeof divide0;
	divide1: typeof divide1;
	divide2: typeof divide2;
	divide3: typeof divide3;
	divide4: typeof divide4;
	dividePoint: (a: Point, b: Point) => Point;
	isPoint: typeof isPoint;
	isPoint0: typeof isPoint0;
	isPoint1: typeof isPoint1;
	isPoint2: typeof isPoint2;
	isPoint3: typeof isPoint3;
	isPoint4: typeof isPoint4;
	isPointObject1: typeof isPointObject1;
	isPointObject2: typeof isPointObject2;
	isPointObject3: typeof isPointObject3;
	isPointObject4: typeof isPointObject4;
	isVec: typeof isVec;
	isVec0: typeof isVec0;
	isVec1: typeof isVec1;
	isVec2: typeof isVec2;
	isVec3: typeof isVec3;
	isVec4: typeof isVec4;
	jsonToPoint3: typeof jsonToPoint3;
	length: typeof length;
	length0: typeof length0;
	length1: typeof length1;
	length2: typeof length2;
	length3: typeof length3;
	length4: typeof length4;
	lengthPoint: typeof lengthPoint;
	lerp: typeof lerp;
	lerp0: (a: Point0, b: Point0, alpha: number) => Point0;
	lerp1: (a: Point1, b: Point1, alpha: number) => Point1;
	lerp2: (a: Point2, b: Point2, alpha: number) => Point2;
	lerp3: (a: Point3, b: Point3, alpha: number) => Point3;
	lerp4: (a: Point4, b: Point4, alpha: number) => Point4;
	lerpPoint: (a: Point, b: Point, alpha: number) => number | PointObject1 | Vec1 | Vec2 | Vec3 | Vec4;
	midPoint2: typeof midPoint2;
	midPoint3: typeof midPoint3;
	multiply: typeof multiply;
	multiply0: typeof multiply0;
	multiply1: typeof multiply1;
	multiply2: typeof multiply2;
	multiply3: typeof multiply3;
	multiply4: typeof multiply4;
	multiplyPoint: typeof multiplyPoint;
	normalize0: typeof normalize0;
	normalize1: typeof normalize1;
	normalize2: typeof normalize2;
	normalize3: typeof normalize3;
	normalize4: typeof normalize4;
	normalizePoint: (point: Point) => Point;
	point3ToJson: typeof point3ToJson;
	quant: ({ v, q, s }: {
		v: number;
		q: number;
		s?: number;
	}) => number;
	scaler: (scale: number) => (value: number) => number;
	scaler0: (scale: Point0) => (value: Point0) => Point0;
	scaler1: (scale: Point1) => (value: Point1) => Point1;
	scaler2: (scale: Point2) => (value: Point2) => Point2;
	scaler3: (scale: Point3) => (value: Point3) => Point3;
	scaler4: (scale: Point4) => (value: Point4) => Point4;
	scalerPoint: (scale: Point) => ((value: Point0) => Point0) | ((value: Point1) => Point1) | ((value: Point2) => Point2) | ((value: Point3) => Point3) | ((value: Point4) => Point4);
	subtract: typeof subtract;
	subtract0: typeof subtract0;
	subtract1: typeof subtract1;
	subtract2: typeof subtract2;
	subtract3: typeof subtract3;
	subtract4: typeof subtract4;
	subtractPoint: typeof subtractPoint;
	toVec: typeof toVec;
	toVec0: typeof toVec0;
	toVec1: typeof toVec1;
	toVec2: typeof toVec2;
	toVec3: typeof toVec3;
	toVec4: typeof toVec4;
	translater: (a: number) => (b: number) => number;
	translater0: (translatePoint: Point0) => (pos: Point0) => Point0;
	translater1: (translatePoint: Point1) => (pos: Point1) => Point1;
	translater2: (translatePoint: Point2) => (pos: Point2) => Point2;
	translater3: (translatePoint: Point3) => (pos: Point3) => Point3;
	translater4: (translatePoint: Point4) => (pos: Point4) => Point4;
	translaterPoint: (translatePoint: Point) => (position: Point) => Point;
	wOf: typeof wOf;
	xOf: typeof xOf;
	yOf: typeof yOf;
	zOf: typeof zOf;
	aOf: <T>(pointVector: T[]) => T;
	bOf: <T_1>(pointVector: T_1[]) => T_1;
	cOf: <T_2>(pointVector: T_2[]) => T_2;
	dOf: <T_3>(pointVector: T_3[]) => T_3;
	eOf: <T_4>(pointVector: T_4[]) => T_4;
	distancePoints2: typeof distancePoints2;
	includesPoint: (points: Point[], p: Point) => boolean;
	removeDuplicatePoints: <P extends Point>(points: P[]) => P[];
	isEqual: (a: Point, b: Point) => boolean;
};
declare function hashFnv32a({ str, seed }: {
	str: string;
	seed?: number;
}): number;
declare function match(s1: string | RegExp, s2: string | RegExp): boolean | undefined;
export declare const Strings: {
	match: typeof match;
	hashFnv32a: typeof hashFnv32a;
	toBytes: (str: string) => Blob;
	toHex: (num: number) => string;
};
export declare const Animates: {
	create: ({ ticksPerSecond, ticker: tickable, running, errorHandler, request, }: AnimationLoopConfig) => AnimateState;
};
export type Tick = {
	lastTickMs: number;
	nextTickMs: number;
	tickCount: number;
	tickStepMs: number;
	frameCount: number;
	deltaMs: number;
	lastDeltaMs: number;
	costMs: number;
	rateLimit: boolean;
};
export type Ticker<R = unknown> = (tick: Tick) => Promise<R> | R;
export type AnimateState = Tick & {
	tickers: Ticker[];
	running: boolean;
	abort: boolean;
};
export type AnimationRequestFunction = (callback: (time: number) => void) => number;
export type AnimationLoopConfig = {
	ticksPerSecond?: number;
	ticker?: Ticker | Ticker[];
	running?: boolean;
	errorHandler?: (error: unknown) => void;
	request?: AnimationRequestFunction;
};
export type AssertionMessage = string | (() => unknown);
declare function assert(value: boolean, message?: AssertionMessage): void;
declare function assertType<T>(value: unknown, typeGuard: (maybe: unknown) => maybe is T, message?: AssertionMessage): T;
declare function assertUnreachable(value: never, message?: AssertionMessage): never;
declare function assertValue<T>(maybe: T, message?: AssertionMessage): NonNullable<T>;
export type ListLike = ArrayLike<unknown> | ArrayBufferLike | ArrayBufferView;
export declare const Asserts: {
	assert: typeof assert;
	assertUnreachable: typeof assertUnreachable;
	assertValue: typeof assertValue;
	assertEqual: <T>(a: T, b: T, message?: AssertionMessage) => void;
	assertNotEqual: <T_1>(a: T_1, b: T_1, message?: AssertionMessage) => void;
	assertEqualElements: (a: ListLike, b: ListLike, message?: AssertionMessage) => void;
	assertType: typeof assertType;
};
export declare const assert: typeof assert, assertValue: typeof assertValue, assertUnreachable: typeof assertUnreachable, assertType: typeof assertType;
export type ColorLike = ColorBuilder | string | Color3 | Color4;
export type ColorModel = "rgb" | "rgba" | "hsl" | "hsla";
export type Color3 = [
	number,
	number,
	number
];
export type Color4 = [
	number,
	number,
	number,
	number
];
export type ColorBuilder = QixColor;
export type ColorOperation = "darken" | "lighten" | "random" | "rotateHue" | "opacity" | "desaturate" | "saturate" | "color";
export type ColorSpec = Partial<{
	[k in ColorOperation]: number | string;
}>;
declare function builder({ color, model, }: {
	color?: ColorLike;
	model?: ColorModel;
}): ColorBuilder;
declare function darken(color: ColorLike, ratio: number): string;
declare function desaturate(color: ColorLike, ratio: number): string;
declare function lighten(color: ColorLike, ratio: number): string;
declare function opacity(color: ColorLike, ratio: number): string;
declare function randomColor(random?: () => number): string;
declare function rotateHue(color: ColorLike, ratio: number): string;
declare function saturate(color: ColorLike, ratio: number): string;
declare function toCssFilters({ someColor, from, }: {
	someColor: ColorLike;
	from: "white" | "black";
}): string;
declare function textColor(colors: string[], threshold?: number): string;
declare function toCss(color: ColorLike, model?: ColorModel): string;
declare function toRgbInteger(color: ColorLike): number;
export declare const Colors: {
	from: (color: ColorLike) => ColorBuilder;
	builder: typeof builder;
	toCss: typeof toCss;
	toRgbInteger: typeof toRgbInteger;
	darken: typeof darken;
	desaturate: typeof desaturate;
	lighten: typeof lighten;
	randomColor: typeof randomColor;
	saturate: typeof saturate;
	textColor: typeof textColor;
	toCssFilters: typeof toCssFilters;
	rotateHue: typeof rotateHue;
	operateOn: (spec: Partial<{
		darken: string | number;
		lighten: string | number;
		random: string | number;
		rotateHue: string | number;
		opacity: string | number;
		desaturate: string | number;
		saturate: string | number;
		color: string | number;
	}>) => string;
	opacity: typeof opacity;
	palletteFrom: (src: string | HTMLImageElement, options: {
		colorCount?: number;
		quality?: number;
	}) => Promise<never>;
};
export declare function isLut(maybe: unknown): maybe is Lut;
export type Lut = {
	s12: (numerator: number) => string;
	s12t: (numerator: number, beta?: number) => string;
	color: (alpha: number) => string;
	text: (alpha: number) => string;
};
declare function expandColors(colors: ColorBuilder[], level?: number): ColorBuilder[];
declare function create(colors: ColorLike[] | Lut, levels?: number): Lut;
export declare const Luts: {
	create: typeof create;
	expandColors: typeof expandColors;
};
export type EventualByteLike = Blob;
export type ImmediateByteLike = string | ArrayBuffer | ArrayBufferView | unknown[];
export type ByteLike = EventualByteLike | ImmediateByteLike;
export type ImageLike = string | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ByteLike;
export declare const Images: {
	toHTMLImageElement: (src: ImageLike) => Promise<HTMLImageElement>;
	toHTMLCanvasElement: (src: ImageLike) => Promise<HTMLCanvasElement>;
	loadHTMLImageElement: (src: string) => Promise<HTMLImageElement>;
	toSrcString: (imageLike: ImageLike) => Promise<string>;
	from: (src: ImageLike) => Promise<{
		update: (updater: (img: import("image-js").Image) => import("image-js").Image) => any;
		toDataURL: () => string;
		toBlob: () => Promise<Blob>;
		get: <T>(getter: (img: import("image-js").Image) => T) => T;
		toHtmlImageElement: () => Promise<HTMLImageElement>;
		mapPixels: <T_1>(mapper: (pixel: number[]) => T_1) => T_1[];
	}>;
	toBlob: (src: ImageLike, type?: string, quality?: number) => Promise<Blob>;
};
export type InputListenOptions = Partial<{
	ratePerSecond: number;
	parent: HTMLElement;
	debug: boolean;
	autoUp: boolean;
	signal: AbortSignal;
	propagate: boolean;
	passive: boolean;
	dropMultiple: boolean;
	animateState: AnimateState;
}>;
export type KeyActions = {
	[k in string]: () => void;
};
export declare const listenToKey: (keyAction: KeyActions, options?: InputListenOptions) => AnimateState;
export type MouseActionEvent = MouseEvent | WheelEvent;
export type PointerEventType = "click" | "auxclick" | "contextmenu" | "pointerdown" | "pointerenter" | "pointerleave" | "pointermove" | "pointerout" | "pointerover" | "wheel" | "pointerup";
export type MouseActions = {
	[k in PointerEventType]: (event: MouseActionEvent) => void;
};
export declare const listenToMouse: (mouseActions: Partial<MouseActions>, options?: InputListenOptions) => AnimateState;
export declare const Inputs: {
	listenToKey: (keyAction: KeyActions, options?: Partial<{
		ratePerSecond: number;
		parent: HTMLElement;
		debug: boolean;
		autoUp: boolean;
		signal: AbortSignal;
		propagate: boolean;
		passive: boolean;
		dropMultiple: boolean;
		animateState: AnimateState;
	}>) => AnimateState;
	listenToMouse: (mouseActions: Partial<MouseActions>, options?: Partial<{
		ratePerSecond: number;
		parent: HTMLElement;
		debug: boolean;
		autoUp: boolean;
		signal: AbortSignal;
		propagate: boolean;
		passive: boolean;
		dropMultiple: boolean;
		animateState: AnimateState;
	}>) => AnimateState;
};
export type SerializableNoiseState = {
	seed: number;
	distance: number;
};
/**
 * @returns 'random' 32bit unsigned
 */
export declare function noise(seed: number): number;
/**
 * creates a hash number using noise function
 * @param data
 * @returns
 */
export declare function noiseHash(data: number[]): number;
/**
 * @returns number between 0 and 1
 */
export declare function noiseUnit(seed: number): number;
/**
 * @param position will be converted to 32bit unsigned
 * @returns 'random' boolean
 */
export declare function noiseBoolean(position: number): boolean;
export declare function noiseStream(seed?: number): () => number;
declare function squirrel3(position: number): number;
export declare const Noises: {
	seed: (seed: any) => void;
	perlin2: (x: number, y: number) => number;
	perlin3: (x: any, y: any, z: any) => number;
	simplex2: (x: number, y: number) => number;
	simplex3: (x: number, y: number, z: number) => number;
	squirrel3: typeof squirrel3;
	noise: typeof noise;
	noiseHash: typeof noiseHash;
	noiseUnit: typeof noiseUnit;
	noiseBoolean: typeof noiseBoolean;
	noiseStream: typeof noiseStream;
	noiseRange: (seed?: number) => (max?: number, min?: number) => number;
	serializableNoiseStream: (state: Partial<SerializableNoiseState>) => () => number;
};
export type TypeGuard<T> = (maybe: unknown) => maybe is T;
export type Producer<T> = () => T;
export type ValueProducer<T> = T | Producer<T>;
export declare const isProducer: <T>(valueProducer: ValueProducer<T>) => valueProducer is Producer<T>;
export type Brand<K, T> = K & {
	__brand: T;
};
declare function times<T>(count: number, mapper: (index: number, stop: () => void) => T): T[];
declare function timesGen<T>(count: number, mapper: (index: number, stop: () => void) => T): Generator<T>;
declare function isIterable<T>(maybe: unknown): maybe is Iterable<T>;
export type Tuple0 = [
];
export type Tuple1<A> = [
	A
];
export type Tuple2<A, B> = [
	A,
	B
];
export type Tuple3<A, B, C> = [
	A,
	B,
	C
];
export type Tuple4<A, B, C, D> = [
	A,
	B,
	C,
	D
];
export type Tuple5<A, B, C, D, E> = [
	A,
	B,
	C,
	D,
	E
];
export declare const tuple0: () => [
];
export declare const tuple1: <A>(a: A) => Tuple1<A>;
export declare const tuple2: <A, B>(a: A, b: B) => Tuple2<A, B>;
export declare const tuple3: <A, B, C>(a: A, b: B, c: C) => Tuple3<A, B, C>;
export declare const tuple4: <A, B, C, D>(a: A, b: B, c: C, d: D) => Tuple4<A, B, C, D>;
export declare const tuple5: <A, B, C, D, E>(a: A, b: B, c: C, d: D, e: E) => Tuple5<A, B, C, D, E>;
export declare const Objects: {
	isIterator: <T>(maybe: unknown) => maybe is Iterator<T, any, undefined>;
	isArrayLike: <T_1>(maybe: unknown) => maybe is ArrayLike<T_1>;
	times: typeof times;
	first: <O, T_2 extends O>(obj: O | Iterator<O, T_2, undefined> | O[], typeGuard?: TypeGuard<T_2>) => T_2;
	last: <T_3>(obj: T_3[]) => T_3;
	fix: <T_4>(v: T_4) => Readonly<FixedBrand<T_4>>;
	iff: <T_5, R>(value: T_5, mapper: (v: NonNullable<T_5>) => R) => R;
	iffTyped: <T_6, R_1, G>(typeGuard: (maybe: unknown) => maybe is G, value: T_6, mapper: (v: T_6 & G) => R_1) => R_1;
	includesUndefined: (...arr: unknown[]) => boolean;
	isDefined: <T_7>(obj: T_7) => obj is NonNullable<T_7>;
	isUndefined: <T_8>(obj: T_8) => obj is null;
	omit: <K extends string | number, T_9 extends {
		[k in K]: unknown;
	}>(object: T_9, key: K) => Omit<T_9, K>;
	omitUnsafe: <K_1 extends string | number, T_10 extends {
		[k_1 in K_1]: unknown;
	}>(object: T_10, key: K_1) => Omit<T_10, K_1>;
	orElse: <T_11>(o: T_11, e: T_11) => T_11;
	removeUndefinedValues: <T_12 extends object>(obj: object) => Partial<T_12>;
	toMany: <T_13>(obj: T_13 | Iterable<T_13> | T_13[]) => T_13[];
	set: <O_1 extends object, K_2 extends keyof O_1 = keyof O_1, V extends O_1[K_2] = O_1[K_2]>(obj: O_1, key: K_2, value: V) => O_1 & {
		[k_2 in K_2]: V;
	};
	setUnsafe: <O_2 extends object, K_3 extends keyof O_2 = keyof O_2, V_1 extends O_2[K_3] = O_2[K_3]>(obj: O_2, key: K_3, value: V_1) => O_2 & {
		[k_3 in K_3]: V_1;
	};
	get: <O_3 extends object, K_4 extends keyof O_3 = keyof O_3>(obj: O_3, key: K_4, defaultValue?: O_3[K_4]) => O_3[K_4];
	update: <O_4 extends object, K_5 extends keyof O_4>(obj: O_4, key: K_5, mapper: (value: O_4[K_5]) => O_4[K_5]) => O_4;
	updateUnsafe: <O_5 extends object, K_6 extends keyof O_5>(obj: O_5, key: K_6, mapper: (value: O_5[K_6]) => O_5[K_6]) => O_5;
	entries: <O_6 extends object, K_7 extends keyof O_6, V_2 = O_6[K_7]>(obj: O_6) => [
		K_7,
		V_2
	][];
	keys: <O_7 extends object, K_8 extends keyof O_7>(obj: O_7) => K_8[];
	values: <O_8 extends object, V_3 = O_8[keyof O_8]>(obj: O_8) => V_3[];
	forEach: <O_9 extends object, K_9 extends keyof O_9>(obj: O_9, consumer: (key: K_9, value: O_9[K_9]) => void, errorHandler?: (error: unknown, key: K_9, value: O_9[K_9]) => void) => void;
	filter: <O_10 extends object, K_10 extends keyof O_10, V_4 extends O_10[K_10]>(obj: O_10, predicate: (key: K_10, value: V_4) => boolean) => [
		K_10,
		V_4
	][];
	chain: <T_14>(initial: T_14, mappers: ((v: T_14) => T_14)[]) => T_14;
	fromEntries: <K_11 extends string | number | symbol, V_5>(entries: readonly (readonly [
		K_11,
		V_5
	])[]) => Record<K_11, V_5>;
	fromEntriesToMultimap: <K_12 extends string | number | symbol, V_6>(entries: [
		K_12,
		V_6
	][]) => Record<K_12, V_6[]>;
	freeze: <T_15>(v: T_15) => Readonly<T_15>;
	hasKey: (obj: object, key: string | string[]) => boolean;
	tuple0: () => [
	];
	tuple1: <A>(a: A) => Tuple1<A>;
	tuple2: <A_1, B>(a: A_1, b: B) => Tuple2<A_1, B>;
	tuple3: <A_2, B_1, C>(a: A_2, b: B_1, c: C) => Tuple3<A_2, B_1, C>;
	tuple4: <A_3, B_2, C_1, D>(a: A_3, b: B_2, c: C_1, d: D) => Tuple4<A_3, B_2, C_1, D>;
	tuple5: <A_4, B_3, C_2, D_1, E>(a: A_4, b: B_3, c: C_2, d: D_1, e: E) => Tuple5<A_4, B_3, C_2, D_1, E>;
	safe: <R_2>(producer: () => R_2, options?: Partial<{
		quiet: boolean;
		def: R_2;
		onError: ValueProducer<string>;
	}>) => R_2;
	safeAsync: <R_3>(producer: () => R_3 | Promise<R_3>, options?: Partial<{
		quiet: boolean;
		def: R_3;
		onError: ValueProducer<string>;
	}>) => Promise<R_3>;
	valueOf: <T_16>(valueProducer: ValueProducer<T_16>) => T_16;
	mapValue: <T_17, R_4>(value: T_17, mapper: (value: T_17) => R_4) => R_4;
	headOf: <O, T_2 extends O>(obj: O | Iterator<O, T_2, undefined> | O[], typeGuard?: TypeGuard<T_2>) => T_2;
	tailOf: <O_11>(obj: O_11[]) => O_11[];
	restOf: <O_11>(obj: O_11[]) => O_11[];
	toMultiMap: <K_13 extends string | number, T_18>(maps: Record<K_13, T_18>[], options?: Partial<{
		compact: boolean;
	}>) => Record<K_13, T_18[]>;
	timesGen: typeof timesGen;
	isIterable: typeof isIterable;
	isBrowser: () => boolean;
	iffBrowser: <T_19>(producer: () => T_19) => T_19;
	mapOf: <K_14 extends string | number | symbol, V_7, R_5>(obj: Record<K_14, V_7>, mapper: (key: K_14, value: V_7) => R_5) => R_5[];
	toPromise: <T_20>(producer: (callback: () => void) => T_20) => Promise<T_20>;
	all: {
		<T_21>(values: Iterable<T_21 | PromiseLike<T_21>>): Promise<Awaited<T_21>[]>;
		<T_22 extends [
		] | readonly unknown[]>(values: T_22): Promise<{
			-readonly [P in keyof T_22]: Awaited<T_22[P]>;
		}>;
	};
	isFunction: (maybe: unknown) => maybe is Function;
};
export declare const from: <T>(value?: number | ArrayLike<T> | Iterable<T>) => T[];
export declare const Arrays: {
	from: <T>(value?: number | ArrayLike<T> | Iterable<T>) => T[];
};
export type FixedBrand<T = unknown> = Brand<T, "Fixed">;
export type Fixed<T = unknown> = Readonly<FixedBrand<T>>;
export declare const isFixed: (maybe: unknown) => maybe is Readonly<{
	__brand: "Fixed";
}>;
export declare const Fixes: {
	fix: <T>(v: T) => Readonly<FixedBrand<T>>;
	extend: <T_1>(arr: T_1[], value: T_1) => Readonly<FixedBrand<T_1[]>>;
	replace: <T_2, A, R>(typeGuard: TypeGuard<T_2>, arr: A[], mapper: (v: T_2) => R) => (A | R)[];
};
export declare const fix: <T>(v: T) => Readonly<FixedBrand<T>>;
export declare const fixObject: <T extends object>(obj: T) => Readonly<FixedBrand<T>> & {
	[x: string]: Readonly<{
		__brand: "Fixed";
	}>;
};
export declare const fixArray: <T>(arr: T[]) => FixedArray<T>;
export type FixedArray<T> = Fixed<T[]> | Fixed<Fixed<T[]>> | Fixed<Fixed<T>[]>;
export declare const extend: <T>(arr: T[], value: T) => Readonly<FixedBrand<T[]>>;
declare function v3(xOrPosition?: number | Point3 | Point2, y?: number, z?: number): Vector3;
export declare const Babs: {
	createEngine: (options?: import("babylonjs/Engines/thinEngine").EngineOptions & {
		antialias?: boolean;
		width?: number;
		height?: number;
		canvas?: HTMLCanvasElement | OffscreenCanvas;
	}) => import("babylonjs/Engines/engine").Engine;
	createCanvas: ({ width, height, }: {
		width: number;
		height: number;
	}) => HTMLCanvasElement;
	renderOnce: (scene: import("babylonjs/scene").Scene) => Promise<void>;
	v3: typeof v3;
	c3: (color: string) => import("babylonjs/Maths/math.color").Color3;
	c4: (color: string) => import("babylonjs/Maths/math.color").Color4;
	describeMesh: (mesh: import("babylonjs/Meshes/abstractMesh").AbstractMesh, search?: RegExp, depth?: number) => void;
	helloWorld: (engine?: import("babylonjs/Engines/engine").Engine) => import("babylonjs/scene").Scene;
	attachEditorControls: (camera: import("babylonjs/Cameras/arcRotateCamera").ArcRotateCamera, options?: Partial<{
		keySensitivity: number;
		mouseSensitivity: number;
		parent: HTMLElement;
		action: () => void;
	}>) => AnimateState[];
};
export type ModelPath = string | File | string[] | File[];
export type ModelBuilder = {
	lock: (id?: string) => Promise<string>;
	unlock: (id: string) => ModelBuilder;
	camera: (x: number, y: number, z: number) => ModelBuilder;
	lookAt: (x: number, y: number, z: number) => ModelBuilder;
	takeCanvas: (width?: number, height?: number) => Promise<HTMLCanvasElement>;
	attachControls: () => ModelBuilder;
	startRenderLoop: () => ModelBuilder;
	reset: () => ModelBuilder;
	describe: (what?: string, search?: RegExp) => ModelBuilder;
	updateColor: (color: string, texture?: RegExp, mesh?: RegExp) => ModelBuilder;
	updateTranslucency: (value: number, texture?: RegExp, mesh?: RegExp) => ModelBuilder;
	gotoFrame: (frame: number) => Promise<void>;
	morph: (influences: Record<string, number>) => ModelBuilder;
	fix: (mapper: ModelMeshMapper) => ModelBuilder;
	fixMesh: (mesh: ModelMesh, mapper: ModelMeshMapper) => ModelBuilder;
	fixMaterial: (mesh: ModelMesh, mapper: ModelMaterialMapper) => ModelBuilder;
	fixTexture: (material: ModelMaterial, mapper: ModelTextureMapper) => ModelBuilder;
	color3: (value: string) => Color3;
	color4: (value: string) => Color4;
	append: (path: ModelPath, name?: string) => Promise<ModelBuilder>;
	createTexture: (image: HTMLCanvasElement | HTMLImageElement) => Promise<ModelTexture>;
	getMorphs: (search?: RegExp) => string[];
	addMorphRemaps: (remaps: MorphRemaps) => ModelBuilder;
	getModelNames: () => string[];
	setClearColor: (color: string) => ModelBuilder;
	setRotation: (model: string, radians: number) => ModelBuilder;
	getBBox: (model: string) => BoundingBox;
	wireframe: () => ModelBuilder;
	pickMesh: (x: number, y: number, predicate?: (mesh: ModelMesh) => boolean) => ModelMesh;
	highlight: (mesh: ModelMesh, color: string) => ModelBuilder;
	unHighlight: (mesh?: ModelMesh) => ModelBuilder;
	addTestCube: () => ModelBuilder;
	render: () => ModelBuilder;
};
export type MorphRemaps = Record<string, string[]>;
export type ModelMesh = AbstractMesh;
export type ModelConcreteMesh = Mesh;
export type ModelNode = Node;
export type ModelMaterial = PBRMaterial;
export type ModelTexture = Texture;
export type ModelColor3 = Color3;
export type ModelColor4 = Color4;
export type ModelBoundingBox = BoundingBox;
export type ModelMeshMapper = (mesh: ModelMesh) => ModelMesh;
export type ModelMaterialMapper = (material: ModelMaterial) => ModelMaterial;
export type ModelTextureMapper = (texture: ModelTexture) => ModelTexture;
export declare const Models: {
	renderOnce: (scene: import("babylonjs/scene").Scene) => Promise<void>;
	loadDazFigure: (props: {
		path: string | File;
		scene: import("babylonjs/scene").Scene;
		name?: string;
	}) => Promise<import("babylonjs/Meshes/abstractMesh").AbstractMesh>;
	fixDazFigure: (scene: import("babylonjs/scene").Scene) => void;
	loadAssetContainer: (scene: import("babylonjs/scene").Scene, path: string | File, options?: Partial<{
		onProgress: (event: import("babylonjs/Loading/sceneLoader").ISceneLoaderProgressEvent) => void;
	}>) => Promise<import("babylonjs/assetContainer").AssetContainer>;
	builder: (props?: {
		scene?: import("babylonjs/scene").Scene;
		path?: ModelPath;
		exposure?: number;
		toneMappingEnabled?: boolean;
		addDefaultLights?: boolean;
		clearColor?: string;
	}) => Promise<ModelBuilder>;
};
declare const TEXTURE_SAMPLING_MODES: {
	linearNearest: number;
	nearestNearest: number;
	linearLinear: number;
	nearestLinear: number;
};
export type ImmediateImage = HTMLCanvasElement | HTMLImageElement | OffscreenCanvas;
export type TextureImageSrc = string | ImmediateImage;
export type TextureLayer = Partial<{
	image: TextureImageSrc;
	color: string;
	size: number;
	_texture: ModelTexture;
	_mesh: ModelMesh;
	_material: StandardMaterial;
	_cached: boolean;
}>;
export type TextureBuilder = {
	addLayer: (layer: TextureLayer) => TextureBuilder;
	render: () => Promise<HTMLCanvasElement | OffscreenCanvas>;
	clear: () => TextureBuilder;
};
export type TextureSamplingModeMap = typeof TEXTURE_SAMPLING_MODES;
export type TextureOptions = Partial<{
	hasAlpha: boolean;
	generateMipMaps: boolean;
	samplingMode: keyof TextureSamplingModeMap;
}>;
export type HtmlElementTextureOptions = Partial<TextureOptions & {
	element: HTMLCanvasElement | HTMLVideoElement;
}>;
export type PathTextureOptions = Partial<TextureOptions & {
	src: string;
}>;
export type DynamicTextureOptions = Partial<TextureOptions & {
	width: number;
	height: number;
	init: (ctx: ICanvasRenderingContext) => void;
}>;
export type AllTextureOptions = HtmlElementTextureOptions & DynamicTextureOptions;
export declare const Textures: {
	builder: ({ size }?: {
		size: number;
	}) => TextureBuilder;
	copyToCanvas: (image: HTMLCanvasElement | OffscreenCanvas | HTMLImageElement, width?: number, height?: number) => HTMLCanvasElement;
	debugImage: (image: HTMLCanvasElement | HTMLImageElement, label?: string) => Promise<unknown>;
	getTexture: <T extends import("babylonjs").BaseTexture>(scene: import("babylonjs").Scene, name: string, producer: () => T) => T;
	getHtmlElementTexture: (scene: import("babylonjs").Scene, name: string, options: Partial<Partial<{
		hasAlpha: boolean;
		generateMipMaps: boolean;
		samplingMode: keyof TextureSamplingModeMap;
	}> & {
		element: HTMLCanvasElement | HTMLVideoElement;
	}>) => import("babylonjs").HtmlElementTexture;
	getDynamicTexture: (scene: import("babylonjs").Scene, name: string, options?: Partial<Partial<{
		hasAlpha: boolean;
		generateMipMaps: boolean;
		samplingMode: keyof TextureSamplingModeMap;
	}> & {
		width: number;
		height: number;
		init: (ctx: ICanvasRenderingContext) => void;
	}>) => import("babylonjs").DynamicTexture;
	getPathTexture: (scene: import("babylonjs").Scene, name: string, options: Partial<Partial<{
		hasAlpha: boolean;
		generateMipMaps: boolean;
		samplingMode: keyof TextureSamplingModeMap;
	}> & {
		src: string;
	}>) => import("babylonjs").Texture;
	updateTexture: (texture: import("babylonjs").BaseTexture, options: AllTextureOptions) => void;
	imageToTexture: (scene: import("babylonjs").Scene, name: string, image: string | HTMLCanvasElement | OffscreenCanvas | HTMLImageElement) => Promise<import("babylonjs").Texture>;
	drawTextOnTexture: (texture: import("babylonjs").DynamicTexture, text: string, options?: Partial<{
		color: string;
		outline: boolean;
		outlineColor: string;
		backgroundColor: string;
		text: string;
		textureSize: number;
		textScale: number;
		rotation: Point3;
		fontFamily: string;
		fontStyle: string;
	}>) => {
		x: number;
		y: number;
		width: number;
		height: number;
	};
	drawOnTexture: (texture: import("babylonjs").DynamicTexture, render: (ctx: ICanvasRenderingContext, size: {
		width: number;
		height: number;
	}) => void) => void;
	drawBackgroundOnTexture: (texture: import("babylonjs").DynamicTexture, options?: Partial<{
		color: string;
	}>) => void;
	clearTexture: (texture: import("babylonjs").DynamicTexture) => void;
	destroyTexture: (scene: import("babylonjs").Scene, name: string) => void;
};
export declare let enabled: boolean;
export declare const stopwatch: (label: string) => (checkpoint?: string) => void;
export declare function time<T>(expr: () => T, label?: string): T;
export declare function timeP<T>(expr: () => Promise<T>, label?: string): Promise<T>;
export declare const Timers: {
	time: typeof time;
	timeP: typeof timeP;
};
export declare const CAMERA_MODES: {
	orthographic: number;
	perspective: number;
};
export type CameraModeMap = typeof CAMERA_MODES;
export type CameraOptions = Partial<{
	mode: keyof CameraModeMap;
	position: Vec3;
	minZ: number;
	maxZ: number;
	target: Vec3;
	orthoTop: number;
	orthoBottom: number;
	orthoLeft: number;
	orthoRight: number;
}>;
export type ArcRotateCameraOptions = Partial<CameraOptions & {
	alpha: number;
	beta: number;
	radius: number;
}>;
export type UniversalCameraOptions = Partial<CameraOptions & {
	rotation: Vec3;
}>;
export type AllCameraOptions = ArcRotateCameraOptions & UniversalCameraOptions;
export declare const Cameras: {
	getArcRotateCamera: (scene: import("babylonjs").Scene, name: string, options?: Partial<Partial<{
		mode: keyof CameraModeMap;
		position: Vec3;
		minZ: number;
		maxZ: number;
		target: Vec3;
		orthoTop: number;
		orthoBottom: number;
		orthoLeft: number;
		orthoRight: number;
	}> & {
		alpha: number;
		beta: number;
		radius: number;
	}>) => import("babylonjs").ArcRotateCamera;
	getCamera: <T extends Camera>(scene: import("babylonjs").Scene, name: string, producer: () => T) => T;
	updateCamera: (camera: Camera, options: AllCameraOptions) => void;
	getUniversalCamera: (scene: import("babylonjs").Scene, name: string, options?: Partial<Partial<{
		mode: keyof CameraModeMap;
		position: Vec3;
		minZ: number;
		maxZ: number;
		target: Vec3;
		orthoTop: number;
		orthoBottom: number;
		orthoLeft: number;
		orthoRight: number;
	}> & {
		rotation: Vec3;
	}>) => import("babylonjs").UniversalCamera;
	attachArcRotateCameraControls: (camera: import("babylonjs").ArcRotateCamera, options?: Partial<{
		keySensitivity: number;
		mouseSensitivity: number;
		parent: HTMLElement;
		action: () => void;
	}>) => AnimateState[];
	attachUniversalCameraControls: (camera: import("babylonjs").UniversalCamera, options?: Partial<{
		keySensitivity: number;
		mouseSensitivity: number;
		parent: HTMLElement;
	}>) => void;
	createTopDownCamera: (scene: import("babylonjs").Scene, name: string, { unitsTall, unitsWide, height, disposeActive, }?: Partial<{
		height: number;
		disposeActive: boolean;
		unitsTall: number;
		unitsWide: number;
	}>) => import("babylonjs").UniversalCamera;
	createDebugCamera: (scene: import("babylonjs").Scene, name: string, {}?: Partial<{}>) => void;
};
export type LightOptions = Partial<{
	intensity: number;
}>;
export type HemisphericLightOptions = Partial<LightOptions & {
	direction: Vec3;
}>;
export type PointLightOptions = Partial<LightOptions & {
	position: Vec3;
}>;
export type AllLightOptions = LightOptions & HemisphericLightOptions & PointLightOptions;
export declare const Lights: {
	getLight: <T extends import("babylonjs/Lights/light").Light>(scene: import("babylonjs/scene").Scene, name: string, producer: () => T) => T;
	getHemisphericLight: (scene: import("babylonjs/scene").Scene, name: string, options?: Partial<Partial<{
		intensity: number;
	}> & {
		direction: Vec3;
	}>) => void;
	getPointLight: (scene: import("babylonjs/scene").Scene, name: string, options?: Partial<Partial<{
		intensity: number;
	}> & {
		position: Vec3;
	}>) => void;
	updateLight: (light: import("babylonjs/Lights/light").Light, options: AllLightOptions) => void;
};
export declare const Meshes: {
	lookAt: (from: Point2, to: Point2) => number;
	getBox: (scene: import("babylonjs/scene").Scene, name: string, options?: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		width: number;
		height: number;
		depth: number;
		colors: string[];
	}>) => import("babylonjs/Meshes/mesh").Mesh;
	getPlane: (scene: import("babylonjs/scene").Scene, name: string, options?: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		width: number;
		height: number;
		tag: string | string[];
		billboard: boolean;
	}>) => import("babylonjs/Meshes/mesh").Mesh;
	getBoxInstance: (scene: import("babylonjs/scene").Scene, name: string, options: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		width: number;
		height: number;
		depth: number;
		receiveShadows: boolean;
	}>) => import("babylonjs/Meshes/instancedMesh").InstancedMesh;
	getSphere: (scene: import("babylonjs/scene").Scene, name: string, options: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		radius: number;
	}>) => import("babylonjs/Meshes/mesh").Mesh;
	getCylinder: (scene: import("babylonjs/scene").Scene, name: string, options?: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		height: number;
		arc: number;
		radius: number;
		tag: string | string[];
	}>) => import("babylonjs/Meshes/mesh").Mesh;
	getTorusKnot: (scene: import("babylonjs/scene").Scene, name: string, options?: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		radius: number;
		material: string;
	}>) => import("babylonjs/Meshes/mesh").Mesh;
	getLine: (scene: import("babylonjs/scene").Scene, name: string, options: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		points: Point3[];
		colors: string[];
		updatable: boolean;
		useVertexAlpha: boolean;
	}>) => import("babylonjs/Meshes/linesMesh").LinesMesh;
	walkMeshes: (mesh: import("babylonjs/Meshes/abstractMesh").AbstractMesh | import("babylonjs/scene").Scene, walker: (mesh: import("babylonjs/Meshes/abstractMesh").AbstractMesh) => void) => any;
	pickMesh: (scene: import("babylonjs/scene").Scene, x: number, y: number, options?: Partial<{
		camera: import("babylonjs/Cameras/camera").Camera;
		predicate: (mesh: import("babylonjs/Meshes/abstractMesh").AbstractMesh) => boolean;
	}>) => import("babylonjs/Meshes/abstractMesh").AbstractMesh;
	getMesh: <T extends import("babylonjs/Meshes/mesh").Mesh | import("babylonjs/Meshes/instancedMesh").InstancedMesh>(scene: import("babylonjs/scene").Scene, name: string, producer?: (instance?: T) => T, updatable?: boolean) => T;
	getMeshAsync: <T_1 extends import("babylonjs/Meshes/mesh").Mesh | import("babylonjs/Meshes/instancedMesh").InstancedMesh>(scene: import("babylonjs/scene").Scene, name: string, producer?: () => Promise<T_1>) => Promise<T_1>;
	calcTopOfMeshWorldPosition: (mesh: import("babylonjs/Meshes/abstractMesh").AbstractMesh) => Point3;
	mergeMeshes: (meshes: import("babylonjs/Meshes/mesh").Mesh[], options?: Partial<{
		disposeSource: boolean;
		allow32BitsIndices: boolean;
		meshSubclass: import("babylonjs/Meshes/mesh").Mesh;
		subdivideWithSubMeshes: boolean;
		multiMultiMaterials: boolean;
	}>) => import("babylonjs/Meshes/mesh").Mesh;
	getVoxModel: (scene: import("babylonjs/scene").Scene, name: string, src: string, options?: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		merged: boolean;
	}>) => import("babylonjs/Particles/solidParticleSystem").SolidParticleSystem;
	calcClientRectForMesh: (mesh: import("babylonjs/Meshes/abstractMesh").AbstractMesh) => {
		width: number;
		height: number;
		left: number;
		top: number;
		right: number;
		bottom: number;
	};
	updateArcRotateCameraPosition: (camera: import("babylonjs/Cameras/arcRotateCamera").ArcRotateCamera, position: Point3) => void;
	findClosestPick: (picks: import("babylonjs/Collisions/pickingInfo").PickingInfo[]) => import("babylonjs/Collisions/pickingInfo").PickingInfo;
	destroyMesh: (scene: import("babylonjs/scene").Scene, name: string, options?: Partial<{
		recurse: boolean;
		disposeMaterials: boolean;
		disposeTextures: boolean;
	}>) => void;
	getMeshInstance: <T_2 extends import("babylonjs/Meshes/mesh").Mesh>(scene: import("babylonjs/scene").Scene, name: string, rootName: string, producer?: () => T_2) => import("babylonjs/Meshes/instancedMesh").InstancedMesh;
	getMeshInstanceAsync: <T_3 extends import("babylonjs/Meshes/mesh").Mesh>(scene: import("babylonjs/scene").Scene, name: string, rootName: string, producer?: () => Promise<T_3>) => Promise<import("babylonjs/Meshes/instancedMesh").InstancedMesh>;
	isInstancedMesh: (mesh: import("babylonjs/Meshes/abstractMesh").AbstractMesh) => mesh is import("babylonjs/Meshes/instancedMesh").InstancedMesh;
	pickMeshes: (scene: import("babylonjs/scene").Scene, x: number, y: number, options?: Partial<{
		camera: import("babylonjs/Cameras/camera").Camera;
		predicate: (mesh: import("babylonjs/Meshes/abstractMesh").AbstractMesh) => boolean;
	}>) => import("babylonjs/Collisions/pickingInfo").PickingInfo[];
	getPolyhedron: (scene: import("babylonjs/scene").Scene, name: string, options?: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}> & Partial<{
		size: number;
		type: "tetrahedron" | "octahedron" | "dodecahedron" | "icosahedron" | "rhombicuboctahadron" | "triangularPrism" | "pentagonalPrism" | "hexagonalPrism" | "squarePyramid" | "pentagonalPyramid" | "triangularDipyramid" | "pentagonalDipryramid" | "elongatedSquareDipyramid" | "elongatedPentagonalDipyramid" | "elongatedPentagonalCupola";
		material: string;
	}>) => import("babylonjs/Meshes/mesh").Mesh;
	updateMesh: (scene: import("babylonjs/scene").Scene, mesh: import("babylonjs/Meshes/mesh").Mesh | import("babylonjs/Meshes/instancedMesh").InstancedMesh, options: Partial<{
		position: PointObject2 | PointObject3 | PointObject4 | Vec4 | Vec3 | Vec2;
		color: string;
		material: string;
		receiveShadows: boolean;
	}>) => void;
};
export type MaterialTypeMap = {
	standard: StandardMaterial;
	pbr: PBRMaterial;
};
export type MaterialOptions = Partial<{
	type: keyof MaterialTypeMap;
}>;
export type StandardMaterialOptions = Partial<MaterialOptions & {
	diffuseTexture: string;
	emissiveTexture: string;
	ambientTexture: string;
	opacityTexture: string;
	diffuseColor: string;
	alpha: number;
	specularColor: string;
	ambientColor: string;
	emissiveColor: string;
}>;
export type PbrMaterialOptions = Partial<{}>;
export type AllMaterialOptions = StandardMaterialOptions & PbrMaterialOptions;
export declare const Materials: {
	getMaterial: <T extends keyof MaterialTypeMap = keyof MaterialTypeMap>(scene: import("babylonjs/scene").Scene, name: string, options?: AllMaterialOptions | T) => MaterialTypeMap[T];
	updateMaterial: (scene: import("babylonjs/scene").Scene, material: import("babylonjs/Materials/material").Material, options: AllMaterialOptions) => void;
	updateStandardMaterial: (scene: import("babylonjs/scene").Scene, material: import("babylonjs/Materials/standardMaterial").StandardMaterial, options: AllMaterialOptions) => void;
};
export declare const createScene: (engine: Engine) => Scene;
export declare const Scenes: {
	createScene: (engine: Engine) => Scene;
	toggleInspector: (scene: Scene) => void;
};
export declare const Shadows: {
	addShadowToMesh: (mesh: import("babylonjs/Meshes/mesh").Mesh | import("babylonjs/Meshes/instancedMesh").InstancedMesh) => () => void;
};
export type SpsOptions = Partial<{
	useModelMaterial: boolean;
}>;
export declare const getParticleSystem: <T extends SolidParticleSystem | IParticleSystem>(scene: Scene, name: string, producer?: () => T) => T;
export declare const getSolidParticleSystem: (scene: Scene, name: string, options?: SpsOptions) => SolidParticleSystem;
export declare const Particles: {
	getSolidParticleSystem: (scene: Scene, name: string, options?: SpsOptions) => SolidParticleSystem;
};
export declare const addGlowLayer: (scene: Scene, name: string, options?: Partial<IGlowLayerOptions>) => GlowLayer;
export declare const Specials: {
	addGlowLayer: (scene: Scene, name: string, options?: Partial<IGlowLayerOptions>) => GlowLayer;
	Constants: typeof Constants;
};
export declare const Nodes: {
	getTransformNode: (scene: import("babylonjs/scene").Scene, name: string) => import("babylonjs/Meshes/transformNode").TransformNode;
};
export declare const Layers: {
	getGlowLayer: (scene: import("babylonjs/scene").Scene, name: string, options?: import("babylonjs/Layers/glowLayer").IGlowLayerOptions) => import("babylonjs/Layers/glowLayer").GlowLayer;
	getHighlightLayer: <T extends import("babylonjs/Layers/highlightLayer").HighlightLayer>(scene: import("babylonjs/scene").Scene, name: string, options?: import("babylonjs/Layers/highlightLayer").IHighlightLayerOptions) => import("babylonjs/Layers/highlightLayer").HighlightLayer;
};
export type SpriteManagerOptions = Partial<{
	capacity: number;
	cellSize: {
		width: number;
		height: number;
	} | number;
	imgUrl: string;
}>;
export declare const getSpriteManager: (scene: Scene, name: string, options?: SpriteManagerOptions) => import("babylonjs").ISpriteManager | SpriteManager;
export declare const getSprite: (scene: Scene, name: string, spriteManagerName: string) => Sprite;
export declare const Sprites: {
	getSpriteManager: (scene: Scene, name: string, options?: SpriteManagerOptions) => import("babylonjs").ISpriteManager | SpriteManager;
	getSprite: (scene: Scene, name: string, spriteManagerName: string) => Sprite;
};
export type NextRandom = {
	(): number;
};
export type MinMax = [
	number,
	number
];
export declare const seedRandom: (seed: number) => NextRandom;
declare function randomUuid(random?: NextRandom): string;
export type RandomIntegerConfig = {
	minMax: MinMax;
	random: NextRandom;
};
declare function randomInteger(config?: Partial<RandomIntegerConfig>): number;
declare function pickRandom<T>(oneOrMany: T | Array<T> | Readonly<Array<T>>, nextRandom?: NextRandom): T;
declare function pickRandomNeighbors(sourceArray: Array<any>, count: number, nextRandom?: NextRandom): any[];
declare function shuffle<T>(oneOrMany: T | Array<T>, random?: NextRandom): Array<T>;
export declare const Randoms: {
	seedRandom: (seed: number) => NextRandom;
	globalRandom: NextRandom;
	randomInteger: typeof randomInteger;
	randomUuid: typeof randomUuid;
	pickRandom: typeof pickRandom;
	pickRandoms: <T>({ from, count, nextRandom, random, forceUnique, }: {
		from: T | T[] | readonly T[];
		count: number;
		nextRandom?: NextRandom;
		random?: NextRandom;
		forceUnique?: boolean;
	}) => T[];
	pickRandomNeighbors: typeof pickRandomNeighbors;
	shuffle: typeof shuffle;
	integerRangeStream: (random: NextRandom) => (max?: number, min?: number) => number;
};
export type XYZ = {
	x: number;
	y: number;
	z: number;
};
export type XYZI = {
	x: number;
	y: number;
	z: number;
	i: number;
};
export type TRN = {
	node_id: number;
	attributes: object;
	child_id: number;
	reserved_id: number;
	number_of_frames: number;
	frame_transforms: object[];
};
export type GRP = {
	id: number;
	attributes: object;
	num_of_children: number;
	child_ids: number[];
};
export type SHP = {
	id: number;
	attributes: object;
	num_of_models: number;
	models: {
		id: number;
		attributes: object;
	}[];
};
export type LAYR = {
	id: number;
	attributes: object;
	reserved_id: number;
};
/** range: 0-255 */
export type RGBA = {
	r: number;
	g: number;
	b: number;
	a: number;
};
/** key is a number in string format */
export type MATL = {
	id: number;
	properties: Record<string, number>;
};
/** key is a number in string format */
export type OBJ = Record<string, number>;
/** reverse engineered, this is NOT definitive :) */
export type VoxData = {
	VOX: number;
	SIZE: XYZ;
	XYZI: XYZI[];
	nTRN: TRN[];
	nGRP: GRP[];
	nSHP: SHP[];
	LAYR: LAYR[];
	RGBA: RGBA[];
	MATL: MATL[];
	rOBJ: OBJ[];
};
export declare const Voxels: {
	animateExplosion: (particle: import("babylonjs/Particles/solidParticle").SolidParticle, options?: Partial<{
		random: NextRandom;
		radius: number;
		maxBounce: number;
		groundZ: number;
		speed: number;
		decay: number;
		dispose: () => void;
	}>) => void;
	voxDataToSps: (scene: import("babylonjs/scene").Scene, voxData: VoxData, name: string) => import("babylonjs/Particles/solidParticleSystem").SolidParticleSystem;
	voxDataToMergedModel: (scene: import("babylonjs/scene").Scene, voxData: VoxData, name: string) => import("babylonjs/Meshes/mesh").Mesh;
	voxDataToComplexModel: (scene: import("babylonjs/scene").Scene, voxData: VoxData, name: string) => import("babylonjs/Meshes/mesh").Mesh;
};
export declare const chain: <T_14>(initial: T_14, mappers: ((v: T_14) => T_14)[]) => T_14, entries: <O_6 extends object, K_7 extends keyof O_6, V_2 = O_6[K_7]>(obj: O_6) => [
	K_7,
	V_2
][], filter: <O_10 extends object, K_10 extends keyof O_10, V_4 extends O_10[K_10]>(obj: O_10, predicate: (key: K_10, value: V_4) => boolean) => [
	K_10,
	V_4
][], first: <O, T_2 extends O>(obj: O | Iterator<O, T_2, undefined> | O[], typeGuard?: TypeGuard<T_2>) => T_2, last: <T_3>(obj: T_3[]) => T_3, forEach: <O_9 extends object, K_9 extends keyof O_9>(obj: O_9, consumer: (key: K_9, value: O_9[K_9]) => void, errorHandler?: (error: unknown, key: K_9, value: O_9[K_9]) => void) => void, iff: <T_5, R>(value: T_5, mapper: (v: NonNullable<T_5>) => R) => R, orElse: <T_11>(o: T_11, e: T_11) => T_11, removeUndefinedValues: <T_12 extends object>(obj: object) => Partial<T_12>, iffTyped: <T_6, R_1, G>(typeGuard: (maybe: unknown) => maybe is G, value: T_6, mapper: (v: T_6 & G) => R_1) => R_1, isDefined: <T_7>(obj: T_7) => obj is NonNullable<T_7>, isUndefined: <T_8>(obj: T_8) => obj is null, omit: <K extends string | number, T_9 extends {
	[k in K]: unknown;
}>(object: T_9, key: K) => Omit<T_9, K>, omitUnsafe: <K_1 extends string | number, T_10 extends {
	[k_1 in K_1]: unknown;
}>(object: T_10, key: K_1) => Omit<T_10, K_1>, toMany: <T_13>(obj: T_13 | Iterable<T_13> | T_13[]) => T_13[], fromEntries: <K_11 extends string | number | symbol, V_5>(entries: readonly (readonly [
	K_11,
	V_5
])[]) => Record<K_11, V_5>, safe: <R_2>(producer: () => R_2, options?: Partial<{
	quiet: boolean;
	def: R_2;
	onError: ValueProducer<string>;
}>) => R_2, safeAsync: <R_3>(producer: () => R_3 | Promise<R_3>, options?: Partial<{
	quiet: boolean;
	def: R_3;
	onError: ValueProducer<string>;
}>) => Promise<R_3>, mapValue: <T_17, R_4>(value: T_17, mapper: (value: T_17) => R_4) => R_4, headOf: <O, T_2 extends O>(obj: O | Iterator<O, T_2, undefined> | O[], typeGuard?: TypeGuard<T_2>) => T_2, tailOf: <O_11>(obj: O_11[]) => O_11[], restOf: <O_11>(obj: O_11[]) => O_11[], times: typeof times, isIterator: <T>(maybe: unknown) => maybe is Iterator<T, any, undefined>, toMultiMap: <K_13 extends string | number, T_18>(maps: Record<K_13, T_18>[], options?: Partial<{
	compact: boolean;
}>) => Record<K_13, T_18[]>, timesGen: typeof timesGen, isIterable: typeof isIterable, isArrayLike: <T_1>(maybe: unknown) => maybe is ArrayLike<T_1>, iffBrowser: <T_19>(producer: () => T_19) => T_19, isBrowser: () => boolean, toPromise: <T_20>(producer: (callback: () => void) => T_20) => Promise<T_20>, all: {
	<T_21>(values: Iterable<T_21 | PromiseLike<T_21>>): Promise<Awaited<T_21>[]>;
	<T_22 extends [
	] | readonly unknown[]>(values: T_22): Promise<{
		-readonly [P in keyof T_22]: Awaited<T_22[P]>;
	}>;
}, isFunction: (maybe: unknown) => maybe is Function;

export {};
