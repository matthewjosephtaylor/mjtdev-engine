import { times } from "./times";
import { timesGen } from "./timesGen";
import { isIterable } from "./type/isIterable";
export declare const Objects: {
    isErrorLike: (maybe: unknown) => maybe is import("..").ErrorLike;
    orError: <T>(f: () => T, options?: Partial<{
        message?: string | undefined;
        cause?: unknown;
    }>) => Error | T;
    tryValue: <T_1>(value: Error | T_1, message?: string | undefined) => T_1;
    isErrorType: (value: unknown) => value is Error;
    isEmpty: (value?: string | number | boolean | undefined) => boolean;
    isNotEmpty: (value?: string | number | boolean | undefined) => boolean;
    isIterator: <T_2>(maybe: unknown) => maybe is Iterator<T_2, any, undefined>;
    isArrayLike: <T_3>(maybe: unknown) => maybe is ArrayLike<T_3>;
    times: typeof times;
    first: <O, T_4 extends O>(obj: O | Iterator<O, T_4, undefined> | O[], typeGuard?: import("..").TypeGuard<T_4>) => T_4 | undefined;
    last: <T_5>(obj: T_5[]) => T_5 | undefined;
    fix: <T_6>(v: T_6) => Readonly<import("..").FixedBrand<T_6>> | undefined;
    iff: <T_7, R>(value: T_7, mapper: (v: NonNullable<T_7>) => R) => R | undefined;
    iffTyped: <T_8, R_1, G>(typeGuard: (maybe: unknown) => maybe is G, value: T_8, mapper: (v: T_8 & G) => R_1) => R_1 | undefined;
    includesUndefined: (...arr: unknown[]) => true | undefined;
    isDefined: <T_9>(obj: T_9 | null | undefined) => obj is NonNullable<T_9>;
    isUndefined: <T_10>(obj: T_10 | null | undefined) => obj is undefined;
    omit: <K extends string | number, T_11 extends { [k in K]: unknown; }>(object: T_11, key: K) => Omit<T_11, K>;
    omitUnsafe: <K_1 extends string | number, T_12 extends { [k_1 in K_1]: unknown; }>(object: T_12, key: K_1) => Omit<T_12, K_1>;
    orElse: <T_13>(o: T_13, e: T_13) => T_13;
    removeUndefinedValues: <T_14 extends object>(obj: object) => Partial<T_14>;
    toMany: <T_15>(obj: T_15 | Iterable<T_15> | T_15[]) => T_15[];
    set: <O_1 extends object, K_2 extends keyof O_1 = keyof O_1, V extends O_1[K_2] = O_1[K_2]>(obj: O_1, key: K_2, value: V) => O_1 & { [k_2 in K_2]: V; };
    setUnsafe: <O_2 extends object, K_3 extends keyof O_2 = keyof O_2, V_1 extends O_2[K_3] = O_2[K_3]>(obj: O_2, key: K_3, value: V_1) => O_2 & { [k_3 in K_3]: V_1; };
    get: <O_3 extends object, K_4 extends keyof O_3 = keyof O_3>(obj: O_3, key: K_4, defaultValue?: O_3[K_4] | undefined) => O_3[K_4] | undefined;
    update: <O_4 extends object, K_5 extends keyof O_4>(obj: O_4, key: K_5, mapper: (value: O_4[K_5]) => O_4[K_5]) => O_4;
    updateUnsafe: <O_5 extends object, K_6 extends keyof O_5>(obj: O_5, key: K_6, mapper: (value: O_5[K_6]) => O_5[K_6]) => O_5;
    entries: <O_6 extends object, K_7 extends keyof O_6, V_2 = O_6[K_7]>(obj: O_6) => [K_7, V_2][];
    keys: <O_7 extends object, K_8 extends keyof O_7>(obj: O_7) => K_8[];
    values: <O_8 extends object, V_3 = O_8[keyof O_8]>(obj: O_8) => V_3[];
    forEach: <O_9 extends object, K_9 extends keyof O_9>(obj: O_9, consumer: (key: K_9, value: O_9[K_9]) => void, errorHandler?: (error: unknown, key: K_9, value: O_9[K_9]) => void) => void;
    filter: <O_10 extends object, K_10 extends keyof O_10, V_4 extends O_10[K_10]>(obj: O_10, predicate: (key: K_10, value: V_4) => boolean) => [K_10, V_4][];
    chain: <T_16>(initial: T_16, mappers: ((v: T_16) => T_16)[]) => T_16;
    fromEntries: <K_11 extends string | number | symbol, V_5>(entries: readonly (readonly [K_11, V_5])[]) => Record<K_11, V_5>;
    fromEntriesToMultimap: <K_12 extends string | number | symbol, V_6>(entries: [K_12, V_6][]) => Record<K_12, V_6[]>;
    freeze: <T_17>(v: T_17) => Readonly<T_17 | undefined>;
    hasKey: (obj: Record<string, any>, key: string | string[]) => boolean;
    tuple0: () => [];
    tuple1: <A>(a: A) => import("./tuples").Tuple1<A>;
    tuple2: <A_1, B>(a: A_1, b: B) => import("./tuples").Tuple2<A_1, B>;
    tuple3: <A_2, B_1, C>(a: A_2, b: B_1, c: C) => import("./tuples").Tuple3<A_2, B_1, C>;
    tuple4: <A_3, B_2, C_1, D>(a: A_3, b: B_2, c: C_1, d: D) => import("./tuples").Tuple4<A_3, B_2, C_1, D>;
    tuple5: <A_4, B_3, C_2, D_1, E>(a: A_4, b: B_3, c: C_2, d: D_1, e: E) => import("./tuples").Tuple5<A_4, B_3, C_2, D_1, E>;
    safe: <R_2>(producer: () => R_2, options?: Partial<{
        quiet: boolean;
        def: R_2;
        onError: import("..").ValueProducer<string>;
    }>) => R_2 | undefined;
    safeAsync: <R_3>(producer: () => R_3 | Promise<R_3>, options?: Partial<{
        quiet: boolean;
        def: R_3;
        onError: import("..").ValueProducer<string>;
    }>) => Promise<R_3 | undefined>;
    valueOf: <T_18>(valueProducer: import("..").ValueProducer<T_18>) => T_18;
    mapValue: <T_19, R_4>(value: T_19, mapper: (value: T_19) => R_4) => R_4;
    headOf: <O, T_4 extends O>(obj: O | Iterator<O, T_4, undefined> | O[], typeGuard?: import("..").TypeGuard<T_4>) => T_4 | undefined;
    tailOf: <O_11>(obj: O_11[]) => O_11[] | undefined;
    restOf: <O_11>(obj: O_11[]) => O_11[] | undefined;
    toMultiMap: <K_13 extends string | number, T_20>(maps: Record<K_13, T_20>[], options?: Partial<{
        compact: boolean;
    }>) => Record<K_13, T_20[]>;
    timesGen: typeof timesGen;
    isIterable: typeof isIterable;
    isBrowser: () => boolean;
    iffBrowser: <T_21>(producer: () => T_21) => T_21 | undefined;
    mapOf: <K_14 extends string | number | symbol, V_7, R_5>(obj: Record<K_14, V_7>, mapper: (key: K_14, value: V_7) => R_5) => R_5[];
    toPromise: <T_22>(producer: (callback: () => void) => T_22) => Promise<T_22>;
    all: {
        <T_23>(values: Iterable<T_23 | PromiseLike<T_23>>): Promise<Awaited<T_23>[]>;
        <T_24 extends [] | readonly unknown[]>(values: T_24): Promise<{ -readonly [P in keyof T_24]: Awaited<T_24[P]>; }>;
    };
    isFunction: (maybe: unknown) => maybe is Function;
    toNumber: (value: string) => number | undefined;
    toBoolean: (value: string) => boolean | undefined;
    waitTimeout: (ms: number) => Promise<unknown>;
};
export * from "./tuples";
//# sourceMappingURL=Objects.d.ts.map